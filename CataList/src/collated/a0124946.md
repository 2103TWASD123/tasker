# a0124946
###### \logic\AddTask.java
``` java
package logic;

import java.util.ArrayList;

public class AddTask extends Task {
	
	private static final String MESSAGE_ADD_SUCCESS = "The event has been added.";
	private static final String MESSAGE_ADD_FAILURE = "Unable to add event.";
	private static final String COMMAND_TYPE = "add";
	
	private static final boolean IS_MUTATOR = true;
	
	//Constructor
	public AddTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_ADD_SUCCESS
				, MESSAGE_ADD_FAILURE);
	}
	
	public AddTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_ADD_SUCCESS
				, MESSAGE_ADD_FAILURE, dateTimeArgs);
	}
	/*
	public AddTask(String userInput, String date, String time){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_ADD_SUCCESS, time, date);
	}

	public void setErrorMessageDefault(){
		this.set_messageToUser(MESSAGE_ADD_FAILURE);
	}
	
	public void setErrorMessageEmpty(){
		this.set_messageToUser(MESSAGE_ADD_EMPTY);
	}
	
	public static String getSuccessMessage(){
		return MESSAGE_ADD_SUCCESS;
	}
	*/
}
```
###### \logic\CalendarTask.java
``` java
package logic;

public class CalendarTask extends Task {
	private static final String MESSAGE_CALENDAR_DEFAULT = "Displaying Calendar";
	private static final String COMMAND_TYPE = "calendar";
	
	private static final boolean IS_MUTATOR = false;
	
	//Constructor
	public CalendarTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_CALENDAR_DEFAULT
				,MESSAGE_CALENDAR_DEFAULT);
	}
}
```
###### \logic\ClearTask.java
``` java
package logic;

import java.util.ArrayList;

public class ClearTask extends Task{
	private static final String MESSAGE_CLEAR_SUCCESS = "Your dashboard has been cleared.";
	private static final String MESSAGE_CLEAR_FAILURE = "Unable to clear dashboard.";
	private static final String COMMAND_TYPE = "clear";
	
	private static final boolean IS_MUTATOR = true;

	//Constructor
	public ClearTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_CLEAR_SUCCESS
				,MESSAGE_CLEAR_FAILURE);
	}
	
	public ClearTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_CLEAR_SUCCESS
				,MESSAGE_CLEAR_FAILURE, dateTimeArgs);
	}
	
}
```
###### \logic\Commands.java
``` java
package logic;

public class Commands {

	public static final String ADD_COMMAND = "add";
	public static final String DELETE_COMMAND = "delete";
	public static final String CLEAR_COMMAND = "clear";
	public static final String DISPLAY_COMMAND = "display";
	public static final String EDIT_COMMAND = "edit";
	public static final String REDO_COMMAND = "redo";
	public static final String UNDO_COMMAND = "undo";
	public static final String MARK_COMMAND = "markcomplete";
	public static final String MARK_INCOMPLETE_COMMAND = "markincomplete";
	public static final String HELP_COMMAND = "help";
	public static final String TUTORIAL_COMMAND = "tutorial";
	public static final String CALENDAR_COMMAND = "calendar";
	public static final String EXIT_COMMAND = "exit";
	public static final String INVALID_COMMAND = "invalid";
	public static final String SEARCH_COMMAND = "search";
	public static final String SAVE_COMMAND = "save";
	public static final String SAVEAS_COMMAND = "saveas";
}
```
###### \logic\DeleteTask.java
``` java
package logic;

import java.util.ArrayList;

public class DeleteTask extends Task{
	
	private static final String MESSAGE_DELETE_SUCCESS = "The event has been deleted.";
	private static final String MESSAGE_DELETE_FAILURE = "Unable to delete event.";
	private static final String COMMAND_TYPE = "delete";
	
	private static final boolean IS_MUTATOR = true;

	//Constructor
	public DeleteTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_DELETE_SUCCESS
				,MESSAGE_DELETE_FAILURE);
	}
	
	public DeleteTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_DELETE_SUCCESS
				,MESSAGE_DELETE_FAILURE, dateTimeArgs);
	}
}
```
###### \logic\DisplayTask.java
``` java
package logic;

import java.util.ArrayList;

public class DisplayTask extends Task {

	private static final String MESSAGE_DISPLAY_SUCCESS = "Displaying Events";
	private static final String MESSAGE_DISPLAY_FAILURE = "Unable to display.";
	private static final String COMMAND_TYPE = "display";
	
	private static final boolean IS_MUTATOR = false;

	//Constructor
	//Constructor
	public DisplayTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_DISPLAY_SUCCESS
				,MESSAGE_DISPLAY_FAILURE);
	}
	
	public DisplayTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_DISPLAY_SUCCESS
				,MESSAGE_DISPLAY_FAILURE, dateTimeArgs);
	}	
}
```
###### \logic\EditTask.java
``` java
package logic;

import java.util.ArrayList;

public class EditTask extends Task{
	
	private static final String MESSAGE_EDIT_SUCCESS = "The event has been edited.";
	private static final String MESSAGE_EDIT_FAILURE = "Unable to edit event.";
	private static final String COMMAND_TYPE = "edit";
	
	private static final boolean IS_MUTATOR = true;
	//Constructor
	public EditTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_EDIT_SUCCESS
				,MESSAGE_EDIT_FAILURE);
	}
	
	public EditTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_EDIT_SUCCESS
				,MESSAGE_EDIT_FAILURE, dateTimeArgs);
	}
}
```
###### \logic\ExitTask.java
``` java
package logic;

public class ExitTask extends Task {
	private static final String MESSAGE_EXIT_DEFAULT = "Displaying Exit";
	private static final String COMMAND_TYPE = "exit";
	
	private static final boolean IS_MUTATOR = false;
	
	//Constructor
	public ExitTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_EXIT_DEFAULT
				,MESSAGE_EXIT_DEFAULT);
	}
}
```
###### \logic\HelpTask.java
``` java
package logic;

import java.util.ArrayList;

public class HelpTask extends Task{
	private static final String MESSAGE_HELP_SUCCESS = "Displaying Help";
	private static final String MESSAGE_HELP_FAILURE = "Unable to display Help";
	private static final String COMMAND_TYPE = "help";
	
	private static final boolean IS_MUTATOR = false;
	
	//Constructor
	public HelpTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_HELP_SUCCESS
				,MESSAGE_HELP_FAILURE);
	}
	
	public HelpTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_HELP_SUCCESS
				,MESSAGE_HELP_FAILURE);
	}
}
```
###### \logic\InvalidTask.java
``` java
package logic;

public class InvalidTask extends Task{
	private static final String MESSAGE_INVALID_DEFAULT = "Invalid command";
	private static final String COMMAND_TYPE = "invalid";
	
	private static final boolean IS_MUTATOR = false;
	
	//Constructor
	public InvalidTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_INVALID_DEFAULT
				,MESSAGE_INVALID_DEFAULT);
	}

}
```
###### \logic\LogicHandler.java
``` java
package logic;

import java.util.ArrayList;

public class LogicHandler {
	
	/**
	 * 	LogicHandler
	 * 	The role of LogicHandler is to operate on a formatted String and create Task Objects accordingly.
	 *  It is called by LogicMain to create Task Objects, which will be returned to LogicMain
	 *  
	 */
	
	private static final String PARSER_UNSUPPORTED_ERROR = "Command not recognized by Logic.";
	private static final String SYMBOL_SPACE = " ";
	private static final String SYMBOL_EMPTY = "";
	
	private static final String[] COMMANDS_REQUIRING_INDEX = {"delete"
															,"display"
															,"edit"
															,"markcomplete"
															,"markincomplete"};
	
	private static final int INPUT_COMMAND_INDEX = 0;
	private static final int INPUT_EVENT_INDEX = 1;
	
	private static final int EVENT_INDEX_NUMBER = 0;
	
	private static final int LIST_DATE_INDEX = 0; 
	private static final int DATE_TIME_SIZE_EMPTY = 0;
	private static final int INPUT_INDEX_CORRECTION = 1;
	
	/**
	 * Public method for the creation of task objects.
	 * @param userInputArray formatted String array that contains all required parameters for Task object creation.
	 * @param dateTimeArgs formatted Date and Time arguments that are to be added to Task Object.
	 * @return Task Object
	 */
	public static Task processCommand(String[] userInputArray
				, ArrayList<ArrayList<String>>dateTimeArgs) {
		
		Task newTask;
		if(isDateTimeEmpty(dateTimeArgs)) {
			newTask = createTaskNoDateTime(userInputArray);
		} else {
			newTask = createTaskWithDateTime(userInputArray, dateTimeArgs);
		}
		updateTaskWithIndex(newTask);
		return newTask;
	}
	
	/**
	 *  Method checks whether a Task object requires an index,
	 *  and if so - calls registerIndex to find and register the index.
	 * @param Task object to be checked.
	 */
	private static void updateTaskWithIndex(Task indexTask) {
		String commandWord = indexTask.get_cmd();
		for(String eachCommand : COMMANDS_REQUIRING_INDEX) {
			if(commandWord.equalsIgnoreCase(eachCommand)) {
				registerIndex(indexTask);
				break;
			}
		}
	}
	
	/**
	 *  Method updates the task object with an Index, if required.
	 * @param Task object to be checked.
	 */
	private static void registerIndex(Task indexTask) {
		String eventPhrase = indexTask.get_task();
		String eventPhraseWithoutIndex = removeFirstWord(eventPhrase);
		indexTask.set_task(eventPhraseWithoutIndex);
		int indexOfTask = eventPhraseIndexParse(eventPhrase);
		indexTask.set_index(indexOfTask);
	}
	
	/**
	 * Method removes the first word of the input
	 * @param eventPhrase
	 * @return String of input with original first word removed.
	 */
	private static String removeFirstWord(String eventPhrase) {
		String[] eventArray = eventPhrase.split(SYMBOL_SPACE);
		String secondWordOnwards = SYMBOL_EMPTY;
		int lastWordIndex = eventArray.length - INPUT_INDEX_CORRECTION;
		for(int i = 1 ; i <= lastWordIndex ; i++) {
			secondWordOnwards += eventArray[i];
			if(i != lastWordIndex) {
				secondWordOnwards += SYMBOL_SPACE;
			}
		}
		return secondWordOnwards;
	}
	
	/**
	 * Method parses the index from userInput, and returns it.
	 * @param eventPhrase
	 * @return int Index
	 */
	private static int eventPhraseIndexParse(String eventPhrase) {
		String[] eventArray = eventPhrase.split(SYMBOL_SPACE);
		String indexWord = eventArray[EVENT_INDEX_NUMBER];
		int parsedIndex = Integer.parseInt(indexWord);
		return parsedIndex;
	}
	
	private static Task createTaskNoDateTime(String[] checkString) {
		String commandType = checkString[INPUT_COMMAND_INDEX];
		String userInputEvent = checkString[INPUT_EVENT_INDEX].trim();
		
		switch(commandType) {
			case Commands.ADD_COMMAND :
				return new AddTask(userInputEvent);
			case Commands.DELETE_COMMAND :
				return new DeleteTask(userInputEvent);
			case Commands.CLEAR_COMMAND :
				return new ClearTask(userInputEvent);
			case Commands.DISPLAY_COMMAND :
				return new DisplayTask(userInputEvent);
			case Commands.EDIT_COMMAND :
				return new EditTask(userInputEvent);
			case Commands.REDO_COMMAND : 
				return new RedoTask(userInputEvent);
			case Commands.UNDO_COMMAND :
				return new UndoTask(userInputEvent);
			case Commands.SEARCH_COMMAND :
				return new SearchTask(userInputEvent);
			case Commands.MARK_COMMAND :
				return new MarkComplete(userInputEvent);
			case Commands.MARK_INCOMPLETE_COMMAND :
				return new MarkIncomplete(userInputEvent);
			case Commands.HELP_COMMAND :
				return new HelpTask(userInputEvent);
			case Commands.TUTORIAL_COMMAND :
				return new TutorialTask(userInputEvent);
			case Commands.CALENDAR_COMMAND  :
				return new CalendarTask(userInputEvent);
			case Commands.EXIT_COMMAND :
				return new ExitTask(userInputEvent);
			case Commands.INVALID_COMMAND :
				return new InvalidTask(userInputEvent);
			case Commands.SAVE_COMMAND :
				return new SaveTask(userInputEvent);
			case Commands.SAVEAS_COMMAND:
				return new SaveAsTask(userInputEvent);
			default: 
				return createTaskWithParserError();
		}
	}
	
	private static Task createTaskWithDateTime(String[] checkString
			, ArrayList<ArrayList<String>> dateTimeArgs) {
		String commandType = checkString[INPUT_COMMAND_INDEX];
		String userInputEvent = checkString[INPUT_EVENT_INDEX];
		
		switch(commandType) {
			case Commands.ADD_COMMAND :
				return new AddTask(userInputEvent, dateTimeArgs);
			case Commands.DELETE_COMMAND :
				return new DeleteTask(userInputEvent, dateTimeArgs);
			case Commands.CLEAR_COMMAND :
				return new ClearTask(userInputEvent, dateTimeArgs);
			case Commands.DISPLAY_COMMAND :
				return new DisplayTask(userInputEvent, dateTimeArgs);
			case Commands.EDIT_COMMAND :
				return new EditTask(userInputEvent, dateTimeArgs);
			case Commands.REDO_COMMAND : 
				return new RedoTask(userInputEvent, dateTimeArgs);
			case Commands.UNDO_COMMAND :
				return new UndoTask(userInputEvent, dateTimeArgs);
			case Commands.SEARCH_COMMAND :
				return new SearchTask(userInputEvent);
			case Commands.MARK_COMMAND :
				return new MarkComplete(userInputEvent);
			case Commands.MARK_INCOMPLETE_COMMAND :
				return new MarkIncomplete(userInputEvent);
			case Commands.HELP_COMMAND :
				return new HelpTask(userInputEvent);
			case Commands.TUTORIAL_COMMAND :
				return new TutorialTask(userInputEvent);
			case Commands.CALENDAR_COMMAND  :
				return new CalendarTask(userInputEvent);
			case Commands.EXIT_COMMAND :
				return new ExitTask(userInputEvent);
			case Commands.INVALID_COMMAND :
				return new InvalidTask(userInputEvent);
			case Commands.SAVE_COMMAND :
				return new SaveTask(userInputEvent);
			default: 
				return createTaskWithParserError();
		}
	}
	
	/**
	 * Method used to create a Task when command is unsupported by Logic components
	 * @return Task which indicates parser error
	 */
	private static Task createTaskWithParserError() {
		Task parserErrorTask = new InvalidTask(PARSER_UNSUPPORTED_ERROR);
		return parserErrorTask;
	}
	
	private static boolean isDateTimeEmpty(ArrayList<ArrayList<String>> dateTimeArgs) {
		ArrayList<String> dateArgs = dateTimeArgs.get(LIST_DATE_INDEX);
		if(dateArgs.size() == DATE_TIME_SIZE_EMPTY) {
			return true;
		} else { 
			return false;
		}
	}
		
	
	
}
```
###### \logic\LogicMain.java
``` java
package logic;

import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;

import parser.ParserMain;
import shared.LogHandler;
import storage.StorageMain;

public class LogicMain {
	
	
	/**
	 * 	LogicMain receives the user input from UI and passes them to Parser and LogicHandler.
	 * 	The role of LogicMain is to operate on Task Objects, created by LogicHandler.
	 *  It also provides API(s) for UI, and provide feedback after every input.
	 *  
	 */
	
	private ArrayList<Task> completeTasks;
	private ArrayList<Task> incompleteTasks;
	private ArrayList<Task> masterListTasks;
	
	private ArrayList<Task> operatingTasks;
	
	private ArrayList<ArrayList<Task>> state;
	private int pointingAt;
	
	private static final int INCOMPLETE_LIST_INDEX = 0;
	private static final int COMPLETE_LIST_INDEX = 1;
	private static final int MASTER_LIST_INDEX = 2;
	private static final int INPUT_INDEX_TO_ARRAY_CORRECTION = 1;
	
	private static final String UNKNOWN_OPERATION_NOTICE = "UNKNOWN OPERATION";
	private static final String SYMBOL_SPACE = " ";
	private static final String SYMBOL_EMPTY = "";
	
	private static final Logger log = LogHandler.retrieveLog();
	ParserMain inputParser;
	StorageMain storageSystem;
	
	/** 
	 * LogicMain()
	 * Initialise LogicMain and its dependencies
	 */
	
	public LogicMain() {
		init();
		regenerateSubListsFromMasterList();
		updateOperating();
		state.add(new ArrayList<Task>(masterListTasks));
		pointingAt = 0;
	}
	
	/**
	 * Method processes user input
	 * by calling dependencies Parser and LogicHandler
	 * @param userInput is the input received from UI.
	 * @return feedBack message generated by command.
	 */
	
	public String processCommand(String userInput) {
		String[] formattedInput = inputParser.processInput(userInput);
		ArrayList<ArrayList<String>> dateTimeArgs = inputParser.processDateTime(userInput);
		Task newCreatedTask = LogicHandler.processCommand(formattedInput, dateTimeArgs);
		String feedbackToUI = operateOnTask(newCreatedTask);

		logList();
		if(isMutatorAndNotUndoRedo(newCreatedTask)) {
			updateState();
		}
		
		sortList();
		regenerateSubListsFromMasterList();
		
		if(!isSearchOrDisplay(newCreatedTask)) {
			updateOperating();
		}
		logList();
		storageSystem.storageWrite(masterListTasks);
		return feedbackToUI;
	}
	
	/**
	 * Method to return list of operatingTasks
	 * @return operatingTasks
	 */
	public ArrayList<Task> getOperatingTasksForUI() {
		return operatingTasks;
	}
	
	/**
	 * Method to return list of completed Tasks
	 * @return completedTasks
	 */
	public ArrayList<Task> getCompleteTasksForUI() {

		return completeTasks;
	}
	
	/**
	 * Method to return list of incomplete tasks
	 * @return incompleteTasks
	 */
	public ArrayList<Task> getIncompleteTasksForUI() {
		return incompleteTasks;
	}
	
	/**
	 * Method to change the contents of operatingTasks to that of Master List
	 */
	public void operatingToMaster(){
		operatingTasks = new ArrayList<Task>(masterListTasks);
	}
	
	/**
	 * Method to change the contents of operatingTasks to that of Incomplete List
	 */
	public void operatingToIncomplete(){
		operatingTasks = new ArrayList<Task>(incompleteTasks);
	}
	
	/**
	 * Method to change the contents of operatingTasks to that of Complete List
	 */
	public void operatingToComplete(){
		operatingTasks = new ArrayList<Task>(completeTasks);
	}
	
	private void init() {
		inputParser = new ParserMain();
		storageSystem = new StorageMain();
		
		masterListTasks = new ArrayList<Task>();
		completeTasks = new ArrayList<Task>();
		incompleteTasks = new ArrayList<Task>();
		state = new ArrayList<ArrayList<Task>>();
		
		masterListTasks = new ArrayList<Task>(storageSystem.loadTask());	
	}
	
	private boolean isSearchOrDisplay(Task taskInput) {
		boolean result = false;
		if(taskInput.get_cmd().equalsIgnoreCase(Commands.SEARCH_COMMAND)) {
			result = true;
		} else if (taskInput.get_cmd().equalsIgnoreCase(Commands.DISPLAY_COMMAND)) {
			result = true;
		}
		return result;
	}	
	
	private String operateOnTask(Task requestedTask) {
		String commandType = requestedTask.get_cmd();
		switch(commandType) {
			case Commands.ADD_COMMAND :
				return doAdd(requestedTask);
			case Commands.DELETE_COMMAND :
				return doDelete(requestedTask);
			case Commands.CLEAR_COMMAND :
				return doClear(requestedTask);
			case Commands.DISPLAY_COMMAND :
				return doDisplay(requestedTask);
			case Commands.EDIT_COMMAND :
				return doEdit(requestedTask);
			case Commands.REDO_COMMAND : 
				return doRedo(requestedTask);
			case Commands.UNDO_COMMAND :
				return doUndo(requestedTask);
			case Commands.SEARCH_COMMAND:
				return doSearch(requestedTask);
			case Commands.MARK_COMMAND :
				return doMarkComplete(requestedTask);
			case Commands.MARK_INCOMPLETE_COMMAND :
				return doMarkIncomplete(requestedTask);
			case Commands.HELP_COMMAND :
			case Commands.TUTORIAL_COMMAND :
			case Commands.CALENDAR_COMMAND :
			case Commands.EXIT_COMMAND :
			case Commands.SAVEAS_COMMAND:
				return opForUI(requestedTask);
			case Commands.INVALID_COMMAND :
				return doInvalid(requestedTask);
			case Commands.SAVE_COMMAND:
				return doSave(requestedTask);
			default: 
				return UNKNOWN_OPERATION_NOTICE;
		}
	}
	
	private void updateState() {
		ArrayList<Task> addToState = new ArrayList<Task>(masterListTasks);
		state.add(addToState);
		pointingAt++;
	}
	
	private void updateOperating() {
		operatingTasks = new ArrayList<Task>(incompleteTasks);
	}
	
	/**
	 * Rebuilds completeTask and incompleteTask from masterList
	 */
	private void regenerateSubListsFromMasterList() {
		incompleteTasks.clear();
		completeTasks.clear();
		for(Task eachTask : masterListTasks) {
			if(eachTask.get_completionState()) {
				completeTasks.add(eachTask);
			} else {
				incompleteTasks.add(eachTask);
			}
		}
	}
	
	private ArrayList<Task> sortList() {
		Collections.sort(masterListTasks);
		return masterListTasks;
	}
	
	/*
	private void saveBackToOriginalList() {
		if(operatingOn == MASTER_LIST_INDEX) {
			masterListTasks = operatingTasks;
		} else if (operatingOn == COMPLETE_LIST_INDEX) {
			completeTasks = operatingTasks;
		} else if (operatingOn == INCOMPLETE_LIST_INDEX) {
			incompleteTasks = operatingTasks;
		}
	}
	*/
	/**
	 * Method checks whether a task is not a REDO/UNDO operation
	 * @param inputTask
	 * @return boolean indicating result
	 */
	private boolean isMutatorAndNotUndoRedo(Task inputTask) {
		boolean result = false;
		if(inputTask.get_cmd().equalsIgnoreCase(Commands.UNDO_COMMAND)
				||inputTask.get_cmd().equalsIgnoreCase(Commands.REDO_COMMAND)) {
			 result = false;
		} else if(inputTask.is_changed()) {
			result = true;
		} 
		return result;
	}
	
	/**
	 * Adds the task to masterListTasks
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doAdd(Task taskToOp) {
		String feedBack;
		try{
			masterListTasks.add(taskToOp);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (Exception e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		return feedBack;
	}
	
	/**
	 * Method deletes all occurrences of this task in masterListTasks and operatingTasks
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doDelete(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		try{
			Task toDelete = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);

			for(int i = 0 ; i < masterListTasks.size() ; i++) {
				if(masterListTasks.get(i).equals(toDelete)) {
					masterListTasks.remove(i);
				}
			}
		
			operatingTasks.remove(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		return feedBack;
	}
	
	/**
	 * Clears every taskList
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doClear(Task taskToOp) {
		String feedBack = taskToOp.get_messageToUserSuccess();
		
		incompleteTasks.clear();
		completeTasks.clear();
		masterListTasks.clear();
		
		operatingTasks.clear();
		return feedBack;
	}
	
	/**
	 * Method changes what operatingTasks contains.
	 * @param taskToOp
	 * @return feedback message
	 */
	
	private String doDisplay(Task taskToOp) {
		int listToDisplay = taskToOp.get_index();
		String feedBack = taskToOp.get_messageToUserSuccess();		
		
		if(listToDisplay == COMPLETE_LIST_INDEX) {
			operatingTasks = new ArrayList<Task>(completeTasks);
		} else if (listToDisplay == INCOMPLETE_LIST_INDEX) {
			operatingTasks = new ArrayList<Task>(incompleteTasks);
		} else if(listToDisplay == MASTER_LIST_INDEX) {
			operatingTasks = new ArrayList<Task>(masterListTasks);
		} else {
			return taskToOp.get_messageToUserFail();
		}

		return feedBack;
	}
	
	/**
	 * Method edits a single task Object
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doEdit(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		
		try{
			Task toEdit = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			Task cloneTask = (Task) toEdit.cloneOf();
			cloneTask.editWith(taskToOp);
		
			doOperateOnMasterAndOperating(toEdit, cloneTask, operateIndex);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	
	private String doUndo(Task taskToOp) {
		String feedBack;
		try{
			pointingAt--;
			masterListTasks = new ArrayList<Task>(state.get(pointingAt));
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	private String doRedo(Task taskToOp) {
		String feedBack;
		try{
			pointingAt++;
			masterListTasks =  new ArrayList<Task>(state.get(pointingAt));
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	/**
	 * Searches through all tasks, adding to list primarily those that fit the search keyword most
	 * followed by substring sequences.
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doSearch(Task taskToOp) {
		String toFind = taskToOp.get_task();
		ArrayList<Task> foundList = new ArrayList<Task>();
		foundList = doSearchFullString(toFind);
		ArrayList<Task> foundListSecondary = doSearchSubsequence(toFind, foundList);
		
		if(!foundListSecondary.isEmpty()) {
			foundList.addAll(foundListSecondary);
		}
		
		operatingTasks = new ArrayList<Task>(foundList);
		return taskToOp.get_messageToUserSuccess();
	}
	
	private ArrayList<Task> doSearchFullString(String toFind) {
		ArrayList<Task> foundList = new ArrayList<Task>();

		for(Task eachTask : masterListTasks) {
			if(eachTask.get_task().contains(toFind)) {
				foundList.add(eachTask);
			}
		}
		return foundList;
	}
	
	private ArrayList<Task> doSearchSubsequence(String toFind, ArrayList<Task> primaryList){
		ArrayList<Task> foundList = new ArrayList<Task>();

		for(Task eachTask : masterListTasks) {
			String[] splitFind = toFind.split(SYMBOL_SPACE);
			for(String eachString : splitFind) {
				if(eachTask.get_task().contains(eachString)) {
					if(!primaryList.contains(eachTask)) {
						foundList.add(eachTask);
					}
				}
			}
		}
		
		return foundList;
	}
	
	private String doMarkComplete(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		try{
			Task operateOn = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			Task cloneTask = (Task) operateOn.cloneOf();
			cloneTask.set_Complete();

			doOperateOnMasterAndOperating(operateOn, cloneTask, operateIndex);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch(IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	private String doMarkIncomplete(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		try{
			Task operateOn = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			Task cloneTask = (Task) operateOn.cloneOf();
			cloneTask.set_Incomplete();
	
			doOperateOnMasterAndOperating(operateOn, cloneTask, operateIndex);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch(IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	private String doInvalid(Task taskToOp) {
		String feedBack = taskToOp.get_messageToUserSuccess();
		return feedBack;
	}
	
	/**
	 * Retrieves a feedback message from tasks
	 * @param taskToOp
	 * @return feedback message
	 */
	private String opForUI(Task taskToOp) {
		String feedBack = taskToOp.get_messageToUserSuccess();
		return feedBack;
	}
	
	/**
	 * Changes file save location.
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doSave(Task taskToOp){
		String feedBack;
		String newLoc = taskToOp.get_task();
		assert newLoc != null;
		assert newLoc != SYMBOL_EMPTY;
		if(!newLoc.isEmpty()) {
			try{
				storageSystem.saveFileLocation(newLoc);
				feedBack = taskToOp.get_messageToUserSuccess();
			} catch (Exception e) {
				log.log(Level.SEVERE, e.toString(), e);
				feedBack = taskToOp.get_messageToUserFail();
			}
		} else {
			feedBack = taskToOp.get_messageToUserFail();
		}
		return feedBack;
	}
	
	/**
	 * Method looks at the task object required to be operated upon
	 * and looks for the same object inside the master list before
	 * executing the same operation on both.
	 * @param operateOn is the task object from operatingTask
	 * @param replaceWith is the task object to be changed
	 * @param operateIndex is the index where operateOn can be found in operatingTask
	 */
	private void doOperateOnMasterAndOperating(Task operateOn, Task replaceWith, int operateIndex) {
		for(int i = 0 ; i < masterListTasks.size() ; i++) {
			if(masterListTasks.get(i).equals(operateOn)) {
				System.out.println(masterListTasks.get(i).get_task() + " is being operated on.");
				masterListTasks.set(i, replaceWith);
			}
		}
		operatingTasks.set(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION, replaceWith);	
	}
	
	private void logList(){
		for(Task eachTask : masterListTasks){
			log.log(Level.FINE, "Item in master list", eachTask);
		}
		
		for(Task eachTask : operatingTasks){
			log.log(Level.FINE, "Item in operating list", eachTask);
		}
		
		for(Task eachTask : completeTasks){
			log.log(Level.FINE, "Item in complete list", eachTask);
		}
		
		for(Task eachTask : incompleteTasks){
			log.log(Level.FINE, "Item in incomplete list", eachTask);
		}
	}
	
}
```
###### \logic\LogicMainAddTest.java
``` java

package logic;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

public class LogicMainAddTest {
	LogicMain logicTest;
	
	@Before
	public void init(){
		logicTest = new LogicMain();
		String userInput6 = "clear";
		String testOutput = logicTest.processCommand(userInput6);

	}
	
	@Test
	public void testAdding(){
		String userInput = "add Fire James 2GD";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
	}
	
	@Test
	public void testAddingWithStartDate(){
		String userInput = "add Fire James 2GD 10feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		assertEquals(startDateResult, startDateTest);
	}
	
	@Test
	public void testAddingWithStartAndEndDate(){
		String userInput = "add Fire James 2GD 10feb 11feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String endDateResult = resultOutput.get_endDate();
		String endDateTest = "11/02/16";
		assertEquals(startDateResult, startDateTest);
		assertEquals(endDateResult, endDateTest);
	}
	
	@Test
	public void testAddingWithStartDateAndStartTime(){
		String userInput = "add Fire James 2GD 10feb 1pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String startTimeResult = resultOutput.get_startTime();
		String startTimeTest = "1.00PM";
		assertEquals(startDateResult, startDateTest);
		assertEquals(startTimeResult, startTimeTest);
	}
	
	@Test
	public void testAddingWithStartAndEnd(){
		String userInput = "add Fire James 2GD 10feb 1pm 11feb 2pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String startTimeResult = resultOutput.get_startTime();
		String startTimeTest = "1.00PM";
		String endDateResult = resultOutput.get_endDate();
		String endDateTest = "11/02/16";
		String endTimeResult = resultOutput.get_endTime();
		String endTimeTest = "2.00PM";
		assertEquals(startDateResult, startDateTest);
		assertEquals(startTimeResult, startTimeTest);
		assertEquals(endDateResult, endDateTest);
		assertEquals(endTimeResult, endTimeTest);
	}
	
	@Test
	public void testAddingWithStartDateAndStartTimeJumbled(){
		String userInput = "add Fire 10feb James 1pm 2GD";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String startTimeResult = resultOutput.get_startTime();
		String startTimeTest = "1.00PM";
		assertEquals(startDateResult, startDateTest);
		assertEquals(startTimeResult, startTimeTest);
	}
	
	@Test
	public void testAddingWithStartDateAndStartTimeJumbledReverse(){
		String userInput = "add Fire 1pm James 10feb 2GD";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String startTimeResult = resultOutput.get_startTime();
		String startTimeTest = "1.00PM";
		assertEquals(startDateResult, startDateTest);
		assertEquals(startTimeResult, startTimeTest);
	}
	
	@Test
	public void testAddingWithStartDateAndEndJumbled(){
		String userInput = "add Fire 10feb James 11FEB 2GD";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String endDateResult = resultOutput.get_endDate();
		String endDateTest = "11/02/16";
		assertEquals(startDateResult, startDateTest);
		assertEquals(endDateResult, endDateTest);
	}
	
	@Test
	public void testAddingWithStartDateAndEndTimeJumbled(){
		String userInput = "add Fire 10feb 1pm James 11FEB 2pm 2GD";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String endDateResult = resultOutput.get_endDate();
		String endDateTest = "11/02/16";
		String startTimeResult = resultOutput.get_startTime();
		String startTimeTest = "1.00PM";
		String endTimeResult = resultOutput.get_endTime();
		String endTimeTest = "2.00PM";
		
		assertEquals(startDateResult, startDateTest);
		assertEquals(startTimeResult, startTimeTest);
		assertEquals(endTimeResult, endTimeTest);
		assertEquals(endDateResult, endDateTest);
	}
	
	@Test
	public void testAddingWithStartDateAndEndJumbled2(){
		String userInput = "add Fire 10feb James 1pm 11FEB 2GD 2pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
		
		String startDateResult = resultOutput.get_startDate();
		String startDateTest = "10/02/16";
		String endDateResult = resultOutput.get_endDate();
		String endDateTest = "11/02/16";
		String startTimeResult = resultOutput.get_startTime();
		String startTimeTest = "1.00PM";
		String endTimeResult = resultOutput.get_endTime();
		String endTimeTest = "2.00PM";
		
		assertEquals(startDateResult, startDateTest);
		assertEquals(startTimeResult, startTimeTest);
		assertEquals(endTimeResult, endTimeTest);
		assertEquals(endDateResult, endDateTest);
	}
	
	@Test
	public void testAddWithNumbersOnly(){
		String userInput = "add 123456789";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "123456789";
		assertEquals(testEventResult, expectedEventResult);
	}
	
	@Test
	public void testAddingWithWhitespaceBefore(){
		String userInput = " add Fire James 2GD";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Invalid command";
		
		assertEquals(testResult, expectedResult);	
	}
	
	@Test
	public void testAddingWithWhitespaceAfter(){
		String userInput = "add  Fire James 2GD";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "Fire James 2GD";
		assertEquals(testEventResult, expectedEventResult);
	}
	
	@Test
	public void testAddingWithNothing(){
		String userInput = "add";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Invalid command";
		
		assertEquals(testResult, expectedResult);	
	}
	
	@Test
	public void testAddWithWhitespacesOnly(){
		String userInput = "add                  ";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Invalid command";
		
		assertEquals(testResult, expectedResult);	
	}

}
```
###### \logic\LogicMainClearTest.java
``` java

package logic;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

public class LogicMainClearTest {
	LogicMain logicTest;
	
	@Before
	public void init(){
		logicTest = new LogicMain();
		String userInput6 = "clear";
		String testOutput = logicTest.processCommand(userInput6);
	}
	
	@Test
	public void testClearing(){
		String userInput1 = "add machine gun noise during livestream";
		String userInput2 = "add VIP room with only plastic chairs";
		String userInput3 = "add 60hz samsung monitors instead of 144hz";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors";
		String userInput5 = "add glue and cardboard to construct soundproof rooms";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		
		String userInput6 = "clear";
		String testOutput = logicTest.processCommand(userInput6);
		String expectedOutput = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput, expectedOutput);
		assertEquals(testList.size(), 0);
	}
	
	@Test
	public void testClearingWithDates(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		
		String userInput6 = "clear";
		String testOutput = logicTest.processCommand(userInput6);
		String expectedOutput = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput, expectedOutput);
		assertEquals(testList.size(), 0);
	}	
	
	@Test
	public void testClearingWhitespaceBefore(){
		String userInput6 = "    clear";
		String testOutput = logicTest.processCommand(userInput6);
		String expectedOutput = "Invalid command";
		assertEquals(testOutput, expectedOutput);
	}
	
	@Test
	public void testClearingWhitespaceAfter(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		
		String userInput6 = "clear      ";
		String testOutput = logicTest.processCommand(userInput6);
		String expectedOutput = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput, expectedOutput);
		assertEquals(testList.size(), 0);
	}
	
	@Test
	public void testClearingWithNumbers(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		String userInput6 = "clear 1";
		String testOutput = logicTest.processCommand(userInput6);
		String expectedOutput = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput, expectedOutput);
		assertEquals(testList.size(), 0);
	}
	
	@Test
	public void testClearingWithDateTime(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);

		String userInput6 = "clear 1pm";
		String testOutput = logicTest.processCommand(userInput6);
		String expectedOutput = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput, expectedOutput);
		assertEquals(testList.size(), 0);
	}
	@Test
	public void testClearingWithDateTime2(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		
		String userInput7 = "clear 1pm 2pm";
		String testOutput2 = logicTest.processCommand(userInput7);
		String expectedOutput2 = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput2, expectedOutput2);
		assertEquals(testList.size(), 0);
	}
	@Test
	public void testClearingWithDateTime3(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		
		String userInput8 = "clear 1pm 1feb";
		String testOutput3 = logicTest.processCommand(userInput8);
		String expectedOutput3 = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput3, expectedOutput3);
		assertEquals(testList.size(), 0);
	}
	
	@Test
	public void testClearingWithDateTime4(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		
		String userInput9 = "clear 1feb";
		String testOutput4 = logicTest.processCommand(userInput9);
		String expectedOutput4 = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput4, expectedOutput4);
		assertEquals(testList.size(), 0);
	}
	
	@Test
	public void testClearingWithDateTime5(){
		String userInput1 = "add machine gun noise during livestream 1pm";
		String userInput2 = "add VIP room with only plastic chairs 10feb";
		String userInput3 = "add 60hz samsung monitors instead of 144hz 10feb 11feb";
		String userInput4 = "add samsung stickers onto valve's 144hz benq monitors 10feb 2pm 11feb 1pm";
		String userInput5 = "add glue and cardboard to construct soundproof rooms 1pm 2pm";
	
		logicTest.processCommand(userInput1);
		logicTest.processCommand(userInput2);
		logicTest.processCommand(userInput3);
		logicTest.processCommand(userInput4);
		logicTest.processCommand(userInput5);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 5);
		
		String userInput10 = "clear 1feb 2feb 1pm 2pm";
		String testOutput4 = logicTest.processCommand(userInput10);
		String expectedOutput4 = "Your dashboard has been cleared.";
		System.out.println(testList.size());
		assertEquals(testOutput4, expectedOutput4);
		assertEquals(testList.size(), 0);
	}
	
}
```
###### \logic\LogicMainDeleteTest.java
``` java

package logic;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

public class LogicMainDeleteTest {
	LogicMain logicTest;
	
	@Before
	public void init(){
		logicTest = new LogicMain();
		String userInput6 = "clear";
		String testOutput = logicTest.processCommand(userInput6);
	}
	
	@Test
	public void testDeleting(){
		String userInput = "add Shanghai Major stream delay pls";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		assertEquals(testResult, expectedResult);
		
		String userInput2 = "delete 1";
		String testResult2 = logicTest.processCommand(userInput2);
		String expectedResult2 = "The event has been deleted.";
		assertEquals(testResult2, expectedResult2);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 0);
			
	}
	
	@Test
	public void testDeletingWithWhiteSpaceBefore(){
		String userInput = "add Shanghai Major stream delay pls";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		assertEquals(testResult, expectedResult);
		
		String userInput2 = " delete 1";
		String testResult2 = logicTest.processCommand(userInput2);
		String expectedResult2 = "Invalid command";
		assertEquals(testResult2, expectedResult2);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 1);
	}
	
	@Test
	public void testDeletingWithWhitespaceAfter(){
		String userInput = "add Shanghai Major stream delay pls";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		assertEquals(testResult, expectedResult);
		
		String userInput2 = "delete      1";
		String testResult2 = logicTest.processCommand(userInput2);
		String expectedResult2 = "The event has been deleted.";
		assertEquals(testResult2, expectedResult2);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 0);
	}
	
	@Test
	public void testDeletingWithIndexOutOfBounds(){
		String userInput = "add Shanghai Major stream delay pls";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		assertEquals(testResult, expectedResult);
		
		String userInput2 = "delete 2";
		String testResult2 = logicTest.processCommand(userInput2);
		String expectedResult2 = "Unable to delete event.";
		assertEquals(testResult2, expectedResult2);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 1);
	}
	
	@Test
	public void testDeletingWithNotNumber(){
		String userInput = "add Shanghai Major stream delay pls";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		assertEquals(testResult, expectedResult);
		
		String userInput2 = "delete two";
		String testResult2 = logicTest.processCommand(userInput2);
		String expectedResult2 = "Invalid command";
		assertEquals(testResult2, expectedResult2);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 1);
	}
	
	@Test
	public void testDeletingWithNotSymbols(){
		String userInput = "add Shanghai Major stream delay pls";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been added.";
		assertEquals(testResult, expectedResult);
		
		String userInput2 = "delete 1!";
		String testResult2 = logicTest.processCommand(userInput2);
		String expectedResult2 = "Invalid command";
		assertEquals(testResult2, expectedResult2);
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		assertEquals(testList.size(), 1);
	}
	
}
```
###### \logic\LogicMainEditTest.java
``` java

package logic;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

public class LogicMainEditTest {
	LogicMain logicTest;
	
	@Before
	public void init(){
		logicTest = new LogicMain();
		String userInput6 = "clear";
		String testOutput = logicTest.processCommand(userInput6);
	}
	
	@Test
	public void testSimpleEdit(){
		String userInputAddToEditNoDateTime = "add editThisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "edit 1 editThatCase";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThatCase";
		assertEquals(testEventResult, expectedEventResult);
	}
	
	@Test
	public void testSimpleEditToDate(){
		String userInputAddToEditNoDateTime = "add editThisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "edit 1 10feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase1";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "10/02/16";
		assertEquals(testEventDate, expectedEventDate);
	}
	
	@Test
	public void testSimpleEditToTime(){
		String userInputAddToEditNoDateTime = "add editThisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "edit 1 1pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase1";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventTime = resultOutput.get_startTime();
		String expectedEventTime = "1.00PM";
		assertEquals(testEventTime, expectedEventTime);
	}
	
	//TODO: BUGGED
	@Test
	public void testSimpleEditToDateTime(){
		String userInputAddToEditNoDateTime = "add editThisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "edit 1 10feb 1pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase1";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "10/02/16";
		assertEquals(testEventDate, expectedEventDate);
		
		String testEventTime = resultOutput.get_startTime();
		String expectedEventTime = "1.00PM";
		assertEquals(testEventTime, expectedEventTime);
	}
	
	@Test
	public void testDateEdit(){
		String userInputAddToEditDate = "add editThisCase2 10feb";
		logicTest.processCommand(userInputAddToEditDate);

		String userInput = "edit 1 editThatCase";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThatCase";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "10/02/16";
		assertEquals(testEventDate, expectedEventDate);
	}
	
	@Test
	public void testDateEditToDate(){
		String userInputAddToEditDate = "add editThisCase2 10feb";
		logicTest.processCommand(userInputAddToEditDate);

		String userInput = "edit 1 11feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase2";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
	}
	
	@Test
	public void testDateEditToTime(){
		String userInputAddToEditDate = "add editThisCase2 10feb";
		logicTest.processCommand(userInputAddToEditDate);

		String userInput = "edit 1 1pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase2";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventTime = resultOutput.get_startTime();
		String expectedEventTime = "1.00PM";
		assertEquals(testEventTime, expectedEventTime);
	}
	
	@Test
	public void testDateEditToDateTime(){
		String userInputAddToEditDate = "add editThisCase2 10feb";
		logicTest.processCommand(userInputAddToEditDate);

		String userInput = "edit 1 11feb 1pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase2";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventTime = resultOutput.get_startTime();
		String expectedEventTime = "1.00PM";
		assertEquals(testEventTime, expectedEventTime);
	}

	@Test
	public void testDateTimeEdit(){
		String userInputAddToEditDateTime = "add editThisCase3 10feb 1pm";
		logicTest.processCommand(userInputAddToEditDateTime);
		
		String userInput = "edit 1 11feb 2pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase3";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventTime = resultOutput.get_startTime();
		String expectedEventTime = "2.00PM";
		assertEquals(testEventTime, expectedEventTime);
	}
	
	@Test
	public void testDateTimeEditJumbled(){
		String userInputAddToEditDateTime = "add editThisCase3 10feb 1pm";
		logicTest.processCommand(userInputAddToEditDateTime);
		
		String userInput = "edit 1 2pm 11feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase3";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventTime = resultOutput.get_startTime();
		String expectedEventTime = "2.00PM";
		assertEquals(testEventTime, expectedEventTime);
	}
	
	@Test
	public void testDateTimeEditJumbled2(){
		String userInputAddToEditDateTime = "add editThisCase3 1pm 10feb";
		logicTest.processCommand(userInputAddToEditDateTime);
		
		String userInput = "edit 1 2pm 11feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase3";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventTime = resultOutput.get_startTime();
		String expectedEventTime = "2.00PM";
		assertEquals(testEventTime, expectedEventTime);
	}
	
	@Test
	public void testStartEndDate(){
		String userInputAddToEditStartEndDates = "add editThisCase4 10feb 11feb";
		logicTest.processCommand(userInputAddToEditStartEndDates);

		String userInput = "edit 1 11feb 12feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase4";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventEnd = resultOutput.get_endDate();
		String expectedEventEnd = "12/02/16";
		assertEquals(testEventEnd, expectedEventEnd);
	}
	
	@Test
	public void testStartEndDateTime(){
		String userInputAddToEditStartEndDates = "add editThisCase4 10feb 11feb";
		logicTest.processCommand(userInputAddToEditStartEndDates);

		String userInput = "edit 1 11feb 1pm 12feb 2pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase4";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventEnd = resultOutput.get_endDate();
		String expectedEventEnd = "12/02/16";
		assertEquals(testEventEnd, expectedEventEnd);
		
		String testEventStartTime = resultOutput.get_startTime();
		String expectedEventStartTime = "1.00PM";
		assertEquals(testEventStartTime, expectedEventStartTime);

		String testEventEndTime = resultOutput.get_endTime();
		String expectedEventEndTime = "2.00PM";
		assertEquals(testEventEndTime, expectedEventEndTime);
	}
	
	@Test
	public void testEditStartEndDateTime(){
		String userInputAddToEditStartEndDateTime = "add editThisCase5 10feb 1pm 11feb 2pm";
		logicTest.processCommand(userInputAddToEditStartEndDateTime);

		String userInput = "edit 1 11feb 2pm 12feb 3pm";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase5";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventEnd = resultOutput.get_endDate();
		String expectedEventEnd = "12/02/16";
		assertEquals(testEventEnd, expectedEventEnd);
		
		String testEventStartTime = resultOutput.get_startTime();
		String expectedEventStartTime = "2.00PM";
		assertEquals(testEventStartTime, expectedEventStartTime);

		String testEventEndTime = resultOutput.get_endTime();
		String expectedEventEndTime = "3.00PM";
		assertEquals(testEventEndTime, expectedEventEndTime);
	}

	@Test
	public void testEditStartEndDateOnly(){
		String userInputAddToEditStartEndDateTime = "add editThisCase5 10feb 1pm 11feb 2pm";
		logicTest.processCommand(userInputAddToEditStartEndDateTime);

		String userInput = "edit 1 11feb 12feb";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);
		
		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		Task resultOutput = testList.get(0);
		String testEventResult = resultOutput.get_task();
		String expectedEventResult = "editThisCase5";
		assertEquals(testEventResult, expectedEventResult);
		
		String testEventDate = resultOutput.get_startDate();
		String expectedEventDate = "11/02/16";
		assertEquals(testEventDate, expectedEventDate);
				
		String testEventEnd = resultOutput.get_endDate();
		String expectedEventEnd = "12/02/16";
		assertEquals(testEventEnd, expectedEventEnd);
		
		String testEventStartTime = resultOutput.get_startTime();
		String expectedEventStartTime = "1.00PM";
		assertEquals(testEventStartTime, expectedEventStartTime);

		String testEventEndTime = resultOutput.get_endTime();
		String expectedEventEndTime = "2.00PM";
		assertEquals(testEventEndTime, expectedEventEndTime);
	}
	
	@Test
	public void editOutOfBounds(){
		String userInputAddToEditNoDateTime = "add editThisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "edit 2 editThatCase";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Unable to edit event.";
		assertEquals(testResult, expectedResult);	
	}
	
	@Test
	public void editWithWhitespaceFront(){
		String userInputAddToEditNoDateTime = "add editThisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = " edit 1 editThatCase";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Invalid command";
		assertEquals(testResult, expectedResult);	
	}
	
	@Test
	public void editWithWhitespaceAfter(){
		String userInputAddToEditNoDateTime = "add editThisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "edit       1 editThatCase";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "The event has been edited.";
		assertEquals(testResult, expectedResult);	
	}
}
```
###### \logic\LogicMainMarkTest.java
``` java

package logic;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

public class LogicMainMarkTest {
	LogicMain logicTest;
	
	@Before
	public void init(){
		logicTest = new LogicMain();
		String userInput6 = "clear";
		String testOutput = logicTest.processCommand(userInput6);
	}
	
	@Test
	public void testSimpleMark(){
		String userInputAdd = "add markhisCase1";
		logicTest.processCommand(userInputAdd);

		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		System.out.println("Size= " +  testList.size());
		
		String userInput = "mark 1";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Event marked completed.";
		assertEquals(testResult, expectedResult);
		
		Task resultOutput = testList.get(0);
		boolean testEventResult = resultOutput.get_completionState();
		boolean expectedEventResult = true;
		assertEquals(testEventResult, expectedEventResult);
	}
	
	@Test
	public void testSimpleUnMark(){
		String userInputAdd = "add markhisCase1";
		logicTest.processCommand(userInputAdd);

		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		System.out.println("Size= " +  testList.size());
		
		String userInput = "mark 1";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Event marked completed.";
		assertEquals(testResult, expectedResult);
		
		Task resultOutput = testList.get(0);
		boolean testEventResult = resultOutput.get_completionState();
		boolean expectedEventResult = true;
		assertEquals(testEventResult, expectedEventResult);
		
		String userInputDisplay = "display 1";
		logicTest.processCommand(userInputDisplay);
		
		String userInput2 = "unmark 1";
		String testResult2 = logicTest.processCommand(userInput2);
		String expectedResult2 = "Event marked as incomplete.";
		assertEquals(testResult2, expectedResult2);
		
		String userInputDisplay2 = "display 2";
		logicTest.processCommand(userInputDisplay2);
		testList = logicTest.getOperatingTasksForUI();
		Task resultOutput2 = testList.get(0);
		boolean testEventResult2 = resultOutput2.get_completionState();
		boolean expectedEventResult2 = false;
		assertEquals(testEventResult2, expectedEventResult2);
	}
	
	@Test
	public void testSimpleMarkWhitespaceBefore(){
		String userInputAddToEditNoDateTime = "add markhisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "     mark 1";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Invalid command";
		assertEquals(testResult, expectedResult);	
	}
	
	@Test
	public void testSimpleMarkOutOfBounds(){
		String userInputAddToEditNoDateTime = "add markhisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "mark 3";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Unable to mark task as complete.";
		assertEquals(testResult, expectedResult);	
	}
	
	@Test
	public void testSimpleUnmarkOutOfBounds(){
		String userInputAddToEditNoDateTime = "add markhisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		String userInput = "unmark 3";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Unable to mark event as incomplete.";
		assertEquals(testResult, expectedResult);	
	}
	
	@Test
	public void testSimpleMarkWhitespaceAfter(){
		String userInputAddToEditNoDateTime = "add markhisCase1";
		logicTest.processCommand(userInputAddToEditNoDateTime);

		ArrayList<Task> testList = logicTest.getOperatingTasksForUI();
		System.out.println("Size= " +  testList.size());
		
		String userInput = "mark     1";
		String testResult = logicTest.processCommand(userInput);
		String expectedResult = "Event marked completed.";
		assertEquals(testResult, expectedResult);
		
		Task resultOutput = testList.get(0);
		boolean testEventResult = resultOutput.get_completionState();
		boolean expectedEventResult = true;
		assertEquals(testEventResult, expectedEventResult);
	}

}
```
###### \logic\MarkComplete.java
``` java

package logic;

import java.util.ArrayList;

public class MarkComplete extends Task{

	private static final String MESSAGE_MARK_COMPLETE_SUCCESS = "Event marked completed.";
	private static final String MESSAGE_MARK_COMPLETE_FAILURE = "Unable to mark task as complete.";
	private static final String COMMAND_TYPE = "markcomplete";
	
	private static final boolean IS_MUTATOR = true;
	
	//Constructor
	public MarkComplete(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_MARK_COMPLETE_SUCCESS
				,MESSAGE_MARK_COMPLETE_FAILURE);
	}
	
	public MarkComplete(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_MARK_COMPLETE_SUCCESS
				,MESSAGE_MARK_COMPLETE_FAILURE);
	}
}
```
###### \logic\MarkIncomplete.java
``` java

package logic;

import java.util.ArrayList;

public class MarkIncomplete extends Task{

	private static final String MESSAGE_MARK_INCOMPLETE_SUCCESS = "Event marked as incomplete.";
	private static final String MESSAGE_MARK_INCOMPLETE_FAILURE = "Unable to mark event as incomplete.";
	private static final String COMMAND_TYPE = "markincomplete";
	
	private static final boolean IS_MUTATOR = true;
	
	//Constructor
	public MarkIncomplete(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_MARK_INCOMPLETE_SUCCESS
				,MESSAGE_MARK_INCOMPLETE_FAILURE);
	}
	
	public MarkIncomplete(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_MARK_INCOMPLETE_SUCCESS
				,MESSAGE_MARK_INCOMPLETE_FAILURE);
	}
}
```
###### \logic\RedoTask.java
``` java

package logic;

import java.util.ArrayList;

public class RedoTask extends Task {
	private static final String MESSAGE_REDO_SUCCESS = "Redo";
	private static final String MESSAGE_REDO_FAILURE = "Unable to redo.";
	private static final String COMMAND_TYPE = "redo";
	
	private static final boolean IS_MUTATOR = true;
	
	//Constructor
	public RedoTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_REDO_SUCCESS
				,MESSAGE_REDO_FAILURE);
	}
	
	public RedoTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_REDO_SUCCESS
				,MESSAGE_REDO_FAILURE, dateTimeArgs);
	}
}
```
###### \logic\SaveAsTask.java
``` java
package logic;

import java.util.ArrayList;

public class SaveAsTask extends Task{
	private static final String MESSAGE_SAVEAS_SUCCESS = "Displaying file explorer";
	private static final String MESSAGE_SAVEAS_FAILURE = "Unable to display file explorer";
	private static final String COMMAND_TYPE = "saveas";
	
	private static final boolean IS_MUTATOR = false;
	
	//Constructor
	public SaveAsTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_SAVEAS_SUCCESS
				,MESSAGE_SAVEAS_FAILURE);
	}
	
	public SaveAsTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_SAVEAS_SUCCESS
				,MESSAGE_SAVEAS_FAILURE);
	}
}
```
###### \logic\SaveTask.java
``` java

package logic;

public class SaveTask extends Task {
	private static final String MESSAGE_SAVE_SUCCESS = "New file location saved";
	private static final String MESSAGE_SAVE_FAIL = "Unable to save new file location.";
	private static final String COMMAND_TYPE = "save";
	
	private static final boolean IS_MUTATOR = false;
	
	//Constructor
	public SaveTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_SAVE_SUCCESS
				,MESSAGE_SAVE_FAIL);
	}
}
```
###### \logic\SearchTask.java
``` java

package logic;

import java.util.ArrayList;

public class SearchTask extends Task {

	private static final String MESSAGE_SEARCH_SUCCESS = "Your search query has returned:";
	private static final String MESSAGE_SEARCH_FAILURE = "Unable to perform search.";
	private static final String COMMAND_TYPE = "search";
	
	private static final boolean IS_MUTATOR = true;
	//constructor
	public SearchTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_SEARCH_SUCCESS
				,MESSAGE_SEARCH_FAILURE);
	}
	
	public SearchTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_SEARCH_SUCCESS
				,MESSAGE_SEARCH_FAILURE, dateTimeArgs);
	}
}
```
###### \logic\Task.java
``` java

package logic;

import java.util.ArrayList;

import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import parser.KeywordConstraints;

public class Task implements Cloneable, Comparable<Task> {
	private static final String SYMBOL_NULL = "";
	
	private boolean _changeDataFlag;
	private String _task;
	private String _cmd;
	private String _messageToUserSuccess;
	private String _messageToUserFail;
	private String _startDate;
	private String _startTime;
	private String _endDate;
	private String _endTime;
	
	private int operandIndex;
	private boolean isComplete;
	
	private static final int STARTINDEX = 0;
	private static final int ENDINDEX = 1;
	private static final int HAVEDATEANDTIME = 2;
	
	private static final int DATEINDEX = 0;
	private static final int TIMEINDEX = 1;
	private static final int HAVESTARTONLY = 1;
	private static final int HAVESTARTANDEND = 2;
	
	public Task (boolean isChanged, String userInput, String cmd
				, String successMsg,String failMsg){
		set_changeDataFlag(isChanged);
		set_task(userInput);
		set_cmd(cmd);
		set_messageToUserSuccess(successMsg);
		set_messageToUserFail(failMsg);
		set_startTime(SYMBOL_NULL);
		set_startDate(SYMBOL_NULL);
		set_endDate(SYMBOL_NULL);
		set_endTime(SYMBOL_NULL);
	}
	
	public Task(boolean isChanged, String userInput, String cmd
				, String successMsg, String failMsg
				, ArrayList<ArrayList<String>> dateTimeArgs){
		this(isChanged, userInput, cmd, successMsg, failMsg);
		
		setDateTimeForTask(dateTimeArgs);
	}
	
	
	@Override
	public boolean equals(Object obj){
		if(obj instanceof Task){
			Task other = (Task)obj;
			return(isEqualCmd(other) 
					&& isEqualMsgFail(other)
					&& isEqualMsgSuccess(other)
					&& isEqualTask(other) 
					&& isSuccesful(other)
					&& isSameStartDate(other)
					&& isSameEndDate(other)
					&& isSameStartTime(other)
					&& isSameEndTime(other)
					&& isSameCompletionState(other));
		}
		return false;
	}
	
	public Task cloneOf(){
		Task newTask;
		try{
			newTask = (Task) this.clone();
		} catch(CloneNotSupportedException e) {
			newTask = new Task(this._changeDataFlag
									,this._task , this._cmd
									,this._messageToUserSuccess
									,this._messageToUserFail);
			newTask.set_startDate(this._startDate);
			newTask.set_endDate(this._endDate);
			newTask.set_startTime(this._startTime);
			newTask.set_endTime(this._endTime);
			
		}
		return newTask;
	}
	
	public void editWith(Task Other){
		if(Other.get_task() != SYMBOL_NULL){
			this.set_task(Other.get_task());
		}

		if(Other.get_startTime() != SYMBOL_NULL){
			this.set_startTime(Other.get_startTime());
		}
		
		if(Other.get_startDate() != SYMBOL_NULL){
			this.set_startDate(Other.get_startDate());
		}
		
		if(Other.get_endTime() != SYMBOL_NULL){
			this.set_endTime(Other.get_endTime());
		}
		
		if(Other.get_endDate() != SYMBOL_NULL){
			this.set_endDate(Other.get_endDate());
		}
		if(Other.get_completionState()){
			this.set_Complete();
		} else {
			this.set_Incomplete();
		}
	}
	
	public Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
	@Override
	public int compareTo(Task Other) {
		int result = 0;
		String thisStart = this.get_startDate();
		String otherStart = Other.get_startDate();
		
		if(thisStart != SYMBOL_NULL && otherStart == SYMBOL_NULL){
			result = -1;
		} else if(thisStart == SYMBOL_NULL && otherStart != SYMBOL_NULL){
			result = 1;
		} else if(thisStart != SYMBOL_NULL && otherStart != SYMBOL_NULL ){
			result = isBeforeOrAfter(Other);
		} else {
			result = this.get_task().compareTo(Other.get_task());
		}

		System.out.println(this.get_task() + " comparing against " + Other.get_task());
		System.out.println("Result = " + result);
		return result;
	}
	
	public boolean isEqualCmd(Task other){
		return (other.get_cmd() == this._cmd);
	}
	
	public boolean isEqualMsgSuccess(Task other){
		return (other.get_messageToUserSuccess() == this._messageToUserSuccess);
	}

	public boolean isEqualMsgFail(Task other){
		return (other.get_messageToUserFail() == this._messageToUserFail);
	}
	
	public boolean isEqualTask(Task other){
		return (other.get_task() == this._task);
	}
	
	public boolean isSuccesful(Task other){
		return (other.is_changed() == this._changeDataFlag);
	}
	
	public boolean isSameStartDate(Task other){
		String otherDate = other.get_startDate();
		String thisDate = this.get_startDate();
		return isSameString(otherDate, thisDate);
	}
	
	public boolean isSameEndDate(Task other){
		String otherDate = other.get_endDate();
		String thisDate = this.get_endDate();
		return isSameString(otherDate, thisDate);
	}
	
	public boolean isSameStartTime(Task other){
		String otherTime = other.get_startTime();
		String thisTime = this.get_startTime();
		return isSameString(otherTime, thisTime);
	}
	
	public boolean isSameEndTime(Task other){
		String otherTime = other.get_endTime();
		String thisTime = this.get_endTime();
		return isSameString(otherTime, thisTime);
	}	
	private boolean isSameString(String otherString, String thisString){
		if(otherString != SYMBOL_NULL && thisString != SYMBOL_NULL){
			return otherString.equals(thisString);
		} else if (otherString == SYMBOL_NULL && thisString == SYMBOL_NULL){
			return true;
		} else {
			return false;
		}
	}
	
	private boolean isSameCompletionState(Task other){
		boolean otherState = other.get_completionState();
		boolean thisState = this.get_completionState();
		return thisState == otherState;
	}
	
	private int isBeforeOrAfter(Task Other){
		DateTimeFormatter formatter = DateTimeFormat.forPattern("dd/MM/yy");
		DateTime thisDate = formatter.parseDateTime(this.get_startDate());
		DateTime otherDate = formatter.parseDateTime(Other.get_startDate());
		int result = 0;
		result = thisDate.compareTo(otherDate);
		
		if(result == 0){
			if(this.get_startTime() != SYMBOL_NULL && Other.get_startTime() != SYMBOL_NULL){
				DateTimeFormatter timeFormatter = DateTimeFormat.forPattern("h.mma");
				DateTime thisTime = timeFormatter.parseDateTime(this.get_startTime());
				DateTime otherTime = timeFormatter.parseDateTime(Other.get_startTime());
				result = thisTime.compareTo(otherTime);
			}
		}
		return result;
	}
	
	private boolean isSameOperand(Task other){
		int otherIndex = other.get_index();
		int thisIndex = this.get_index();
		return thisIndex == otherIndex;
	}
		
	/************GETTERS***********/
	public boolean is_changed() {
		return _changeDataFlag;
	}

	public String get_cmd() {
		return _cmd;
	}

	public String get_task() {
		return _task;
	}
	
	public String get_messageToUserSuccess() {
		return _messageToUserSuccess;
	}
	
	public String get_messageToUserFail() {
		return _messageToUserFail;
	}
	
	public String get_startDate() {
		return _startDate;
	}

	public String get_startTime() {
		return _startTime;
	}
	
	public String get_endTime(){
		return _endTime;
	}
	
	public String get_endDate(){
		return _endDate;
	}
	
	public int get_index(){
		return operandIndex;
	}
	
	public boolean get_completionState(){
		return isComplete;
	}

	/************SETTERS***********/
	public void set_task(String _task) {
		this._task = _task;
	}

	public void set_changeDataFlag(boolean _changes) {
		this._changeDataFlag = _changes;
	}
	
	public void set_cmd(String _cmd) {
		this._cmd = _cmd;
	}
	
	public void set_messageToUserSuccess(String _messageToUserSuccess) {
		this._messageToUserSuccess = _messageToUserSuccess;
	}

	public void set_messageToUserFail(String _messageToUserFail) {
		this._messageToUserFail = _messageToUserFail;
	}
	
	public void set_startDate(String date1) {
		this._startDate = date1;
	}

	public void set_startTime(String time1) {
		this._startTime = time1;
	}

	public void set_endDate(String date2) {
		this._endDate = date2;
	}

	public void set_endTime(String time2) {
		this._endTime = time2;
	}
	
	public void set_index(int newIndex){
		this.operandIndex = newIndex;
	}
	
	public void set_Complete(){
		this.isComplete = true;
	}
	
	public void set_Incomplete(){
		this.isComplete = false;
	}
	
	public void setMessageErrorCustom(String customErrorMsg){
		this._messageToUserFail = customErrorMsg;
	}
	
	public void setDateTimeForTask(ArrayList<ArrayList<String>> dateTimeArgs){
		ArrayList<String> dateArgs = dateTimeArgs.get(DATEINDEX);
		ArrayList<String> timeArgs = dateTimeArgs.get(TIMEINDEX);

		if(dateArgs.size() == HAVESTARTONLY){
			this.set_startDate(dateArgs.get(STARTINDEX));
		} else if (dateArgs.size() == HAVESTARTANDEND){
			this.set_startDate(dateArgs.get(STARTINDEX));
			this.set_endDate(dateArgs.get(ENDINDEX));	
		}
		
		if(timeArgs.size() == HAVESTARTONLY){
			this.set_startTime(timeArgs.get(STARTINDEX));
		} else if (timeArgs.size() == HAVESTARTANDEND){
			this.set_startTime(timeArgs.get(STARTINDEX));
			this.set_endTime(timeArgs.get(ENDINDEX));	
		}
	}

}
```
###### \logic\TutorialTask.java
``` java

package logic;

public class TutorialTask extends Task {
	private static final String MESSAGE_TUTORIAL_DEFAULT = "Displaying Tutorial";
	private static final String COMMAND_TYPE = "tutorial";
	
	private static final boolean IS_MUTATOR = false;
	
	//Constructor
	public TutorialTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_TUTORIAL_DEFAULT
				,MESSAGE_TUTORIAL_DEFAULT);
	}
}
```
###### \logic\UndoTask.java
``` java

package logic;

import java.util.ArrayList;

public class UndoTask extends Task{
	private static final String MESSAGE_UNDO_SUCCESS = "Undo";
	private static final String MESSAGE_UNDO_FAILURE = "Unable to undo.";
	private static final String COMMAND_TYPE = "undo";
	
	private static final boolean IS_MUTATOR = true;
	
	//Constructor
	public UndoTask(String userInput){
		super(IS_MUTATOR, userInput, COMMAND_TYPE, MESSAGE_UNDO_SUCCESS
				,MESSAGE_UNDO_FAILURE);
	}
	
	public UndoTask(String userInput, ArrayList<ArrayList<String>> dateTimeArgs){
		super(IS_MUTATOR,userInput, COMMAND_TYPE, MESSAGE_UNDO_SUCCESS
				,MESSAGE_UNDO_FAILURE, dateTimeArgs);
	}}
```
###### \parser\CommandParser.java
``` java

package parser;

import logic.Commands;

public class CommandParser {
	
	private static final int COMMAND_INDEX = 0;
	private static final String SYMBOL_WHITESPACE = " ";
	
	public static String parseCommand(String userInput){
		String firstWord = extractFirstWord(userInput);
		String identifiedCommand = analyzeWord(firstWord);
		return identifiedCommand;
	}
	
	private static String extractFirstWord(String userInput){
		String[] resultingArray = userInput.split(SYMBOL_WHITESPACE);
		String firstWord = resultingArray[COMMAND_INDEX];
		return firstWord;
	}
	 
	private static boolean compareKeywords(String stringToTest, String[] arrayOfKeywords){
		boolean isKeyword = false;
		for(String supportedKeywords : arrayOfKeywords){
			if(stringToTest.equalsIgnoreCase(supportedKeywords)){
				isKeyword = true;
				break;
			}
		}
		return isKeyword;
	}
	
	private static String analyzeWord(String stringToTest){
		if(compareAddKeywords(stringToTest)){
			return Commands.ADD_COMMAND;
		} else if (compareDeleteKeywords(stringToTest)){
			return Commands.DELETE_COMMAND;
		} else if (compareClearKeywords(stringToTest)){
			return Commands.CLEAR_COMMAND;
		} else if (compareDisplayKeywords(stringToTest)){
			return Commands.DISPLAY_COMMAND;
		} else if (compareEditKeywords(stringToTest)){
			return Commands.EDIT_COMMAND;
		} else if (compareRedoKeywords(stringToTest)){
			return Commands.REDO_COMMAND;
		} else if (compareUndoKeywords(stringToTest)){
			return Commands.UNDO_COMMAND;
		} else if (compareSearchKeywords(stringToTest)){
			return Commands.SEARCH_COMMAND;
		} else if (compareMarkCompleteKeywords(stringToTest)){
			return Commands.MARK_COMMAND;
		} else if (compareMarkIncompleteKeywords(stringToTest)){
			return Commands.MARK_INCOMPLETE_COMMAND;
		} else if (compareExitKeywords(stringToTest)){
			return Commands.EXIT_COMMAND;
		} else if (compareHelpKeywords(stringToTest)){
			return Commands.HELP_COMMAND;
		} else if (compareCalendarKeywords(stringToTest)){
			return Commands.CALENDAR_COMMAND;
		} else if (compareTutorialKeywords(stringToTest)){
			return Commands.TUTORIAL_COMMAND;
		} else if (compareSaveKeywords(stringToTest)) {
			return Commands.SAVE_COMMAND;
		} else if (compareSaveToKeywords(stringToTest)) {
			return Commands.SAVEAS_COMMAND;
		} else {
			return Commands.INVALID_COMMAND;
		}
	}
	
	private static boolean compareAddKeywords(String stringToTest){
		boolean isAddKeyword = false;
		isAddKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_ADD);
		return isAddKeyword;
	}
	
	private static boolean compareDeleteKeywords(String stringToTest){
		boolean isDeleteKeyword = false;
		isDeleteKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_DELETE);
		return isDeleteKeyword;
	}
	
	private static boolean compareClearKeywords(String stringToTest){
		boolean isClearKeyword = false;
		isClearKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_CLEAR);
		return isClearKeyword;
	}
	
	private static boolean compareDisplayKeywords(String stringToTest){
		boolean isDisplayKeyword = false;
		isDisplayKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_DISPLAY);
		return isDisplayKeyword;
	}
	
	private static boolean compareEditKeywords(String stringToTest){
		boolean isEditKeyword = false;
		isEditKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_EDIT);
		return isEditKeyword;
	}
	
	private static boolean compareRedoKeywords(String stringToTest){
		boolean isRedoKeyword = false;
		isRedoKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_REDO);
		return isRedoKeyword;
	}
	
	private static boolean compareUndoKeywords(String stringToTest){
		boolean isUndoKeyword = false;
		isUndoKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_UNDO);
		return isUndoKeyword;
	}
	
	private static boolean compareSearchKeywords(String stringToTest){
		boolean isSearchKeyword = false;
		isSearchKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_SEARCH);
		return isSearchKeyword;
	}
	
	private static boolean compareMarkCompleteKeywords(String stringToTest){
		boolean isMarkCompleteKeyword = false;
		isMarkCompleteKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_MARK_COMPLETE);
		return isMarkCompleteKeyword;
	}
	
	private static boolean compareMarkIncompleteKeywords(String stringToTest){
		boolean isMarkIncompleteKeyword = false;
		isMarkIncompleteKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_MARK_INCOMPLETE);
		return isMarkIncompleteKeyword;
	}
	
	private static boolean compareExitKeywords(String stringToTest){
		boolean isExitKeyword = false;
		isExitKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_EXIT);
		return isExitKeyword;
	}
	
	private static boolean compareHelpKeywords(String stringToTest){
		boolean isHelpKeyword = false;
		isHelpKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_HELP);
		return isHelpKeyword;
	}
	
	private static boolean compareCalendarKeywords(String stringToTest){
		boolean isCalKeyword = false;
		isCalKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_CALENDAR);
		return isCalKeyword;
	}
	
	private static boolean compareTutorialKeywords(String stringToTest){
		boolean isTutKeyword = false;
		isTutKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_TUTORIAL);
		return isTutKeyword;
	}
	
	private static boolean compareSaveKeywords(String stringToTest){
		boolean isTutKeyword = false;
		isTutKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_SAVE);
		return isTutKeyword;
	}
	
	private static boolean compareSaveToKeywords(String stringToTest){
		boolean isTutKeyword = false;
		isTutKeyword = compareKeywords(stringToTest, KeywordConstraints.KW_TASK_SAVETO);
		return isTutKeyword;
	}
}
```
###### \parser\CommandParserTest.java
``` java

package parser;

import static org.junit.Assert.assertEquals;

import java.util.logging.Logger;

import org.junit.Test;

public class CommandParserTest {
	 private static final Logger logger =
		        Logger.getLogger(CommandParserTest.class.getName());
	 
	@Test
	public void AddCommandTest(){
		logger.entering(getClass().getName(), "AddTest");
		
		String userInput1 = "add \"Fire James 2GD";
		String userInput2 = "/a Fire James 2GD";
		String userInput3 = "-a Fire James 2GD";
		String userInput4 = "++ Fire James 2GD";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		String result4 = CommandParser.parseCommand(userInput4);
		
		String expectedResult = "add";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);
		assertEquals(expectedResult, result4);
		logger.exiting(getClass().getName(), "add test");
	}
	
	@Test
	public void DeleteCommandTest(){
		String userInput1 = "delete Fire James 2GD";
		String userInput2 = "rm Fire James 2GD";
		String userInput3 = "del Fire James 2GD";
		String userInput4 = "-del Fire James 2GD";
		String userInput5 = "/del Fire James 2GD";
		String userInput6 = "-- Fire James 2GD";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		String result4 = CommandParser.parseCommand(userInput4);
		String result5 = CommandParser.parseCommand(userInput5);
		String result6 = CommandParser.parseCommand(userInput6);
		
		String expectedResult = "delete";
		System.out.println(result1);
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);
		assertEquals(expectedResult, result4);
		assertEquals(expectedResult, result5);
		assertEquals(expectedResult, result6);
	}
	
	@Test
	public void ClearCommandTest(){
		String userInput1 = "clear";
		String userInput2 = "nuke";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		
		String expectedResult = "clear";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
	}
	
	@Test
	public void DisplayCommandTest(){
		String userInput1 = "ls";
		String userInput2 = "display";
		String userInput3 = "show";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		
		String expectedResult = "display";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);		
	}
	
	@Test
	public void SearchCommandTest(){
		String userInput1 = "search";
		String userInput2 = "find";
		String userInput3 = "/find";
		String userInput4 = "/f";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		String result4 = CommandParser.parseCommand(userInput4);
		
		String expectedResult = "search";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);		
		assertEquals(expectedResult, result4);		
	}
	
	@Test
	public void EditCommandTest(){
		String userInput1 = "edit";
		String userInput2 = "change";
		String userInput3 = "update";
		String userInput4 = "-e";
		String userInput5 = "/e";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		String result4 = CommandParser.parseCommand(userInput4);
		String result5 = CommandParser.parseCommand(userInput5);
		
		String expectedResult = "edit";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);		
		assertEquals(expectedResult, result4);		
		assertEquals(expectedResult, result5);		
	}	

	@Test
	public void MarkCompleteCommandTest(){
		String userInput1 = "done";
		String userInput2 = "mark";
		String userInput3 = "complete";
		String userInput4 = "-c";
		String userInput5 = "/c";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		String result4 = CommandParser.parseCommand(userInput4);
		String result5 = CommandParser.parseCommand(userInput5);
		
		String expectedResult = "markcomplete";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);		
		assertEquals(expectedResult, result4);		
		assertEquals(expectedResult, result5);		
	}
	
	@Test
	public void MarkIncompleteCommandTest(){
		String userInput1 = "undone";
		String userInput2 = "unmark";
		String userInput3 = "notdone";
		String userInput4 = "incomplete";
		String userInput5 = "/ic";
		String userInput6 = "-ic";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		String result4 = CommandParser.parseCommand(userInput4);
		String result5 = CommandParser.parseCommand(userInput5);
		String result6 = CommandParser.parseCommand(userInput6);
		
		String expectedResult = "markincomplete";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);		
		assertEquals(expectedResult, result4);		
		assertEquals(expectedResult, result5);		
		assertEquals(expectedResult, result6);		
	}
	
	@Test
	public void UndoCommandTest(){
		String userInput1 = "undo";
		String userInput2 = "/u";
		String userInput3 = "-u";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		
		String expectedResult = "undo";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);		
	}

	@Test
	public void RedoCommandTest(){
		String userInput1 = "redo";
		String userInput2 = "/r";
		String userInput3 = "-r";
		
		String result1 = CommandParser.parseCommand(userInput1);
		String result2 = CommandParser.parseCommand(userInput2);
		String result3 = CommandParser.parseCommand(userInput3);
		
		String expectedResult = "redo";
		
		assertEquals(expectedResult, result1);
		assertEquals(expectedResult, result2);
		assertEquals(expectedResult, result3);		
	}
	

}
```
###### \parser\DateTimeParser.java
``` java

package parser;

import java.util.ArrayList;

import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.LocalTime;
import org.joda.time.format.DateTimeFormat;

public class DateTimeParser {
	private static final String SYMBOL_EMPTY = "";
	private static final int EMPTY_SIZE = 0;
	private static final int SIZE_ONE = 1;
	
	protected static final String INVALID_DATE_MESSAGE = "Invalid date input";
	protected static final String INVALID_TIME_MESSAGE = "Invalid time input";
	
	/**
	 * Parses date time from userInput.
	 * Calls Date parser and Time Parser, before combining the results and returning to caller.
	 * @param userInput
	 * @return ArrayList of ArrayList that contains the parsed date and time arguments.
	 */
	public static ArrayList<ArrayList<String>> parseDateTime(String userInput){
		String[] splitInput = userInput.split(" ");
		ArrayList<String> dateArgs = parseStartEndDates(splitInput);
		ArrayList<String> timeArgs = parseStartEndTimes(splitInput);

		if(dateArgs.size() == EMPTY_SIZE && timeArgs.size() != EMPTY_SIZE){
			if(timeArgs.size() == SIZE_ONE){
				dateArgs.add(getToday());
			} else {
				dateArgs.add(getToday());
				dateArgs.add(getToday());
			}
		}
		ArrayList<ArrayList<String>> results = new ArrayList<ArrayList<String>>();
		results.add(dateArgs);
		results.add(timeArgs);
		return results;
	}
	
	/*
	private static int searchForDateFlagsIndex(String[] splittedInput){
		int indexOfDate = 0;
		for(int i = 0; i <splittedInput.length; i++){
			for(String eachKeyword : KeywordConstraints.KW_DATE_FLAG){
				if(splittedInput[i].contains(eachKeyword)){
					indexOfDate = i;
					break;
				}
			}
		}
		return indexOfDate + 1;
	}
	
	private static int searchForTimeFlagsIndex(String[] splittedInput){
		int indexOfTime = 0;
		for(int i = 0 ; i<splittedInput.length; i++){
			for(String eachKeyword : KeywordConstraints.KW_TIME_FLAG){
				if(splittedInput[i].contains(eachKeyword)){
					indexOfTime = i;
					break;
				}
			}
		}
		return indexOfTime + 1;
	}
	*/
	
	/**
	 * Method parses a String array to look for dates
	 * @param splitInput
	 * @return ArrayList containing dates
	 */
	private static ArrayList<String> parseStartEndDates(String[] splitInput){
		String startDate;
		int length = splitInput.length;
		int startIndex = 0;
		ArrayList<String> results = new ArrayList<String>();
		
		for(int i = 0 ; i < length ; i++){
			startDate = parseForDate(splitInput[i]);
			if(!startDate.equalsIgnoreCase(SYMBOL_EMPTY)){
				results.add(startDate);
				startIndex = i;
				break;
			}
		}
		
		if(startIndex != 0 && startIndex < length){
			String endDate;
			for(int j = startIndex + 1 ; j < length ; j++){
				endDate = parseForDate(splitInput[j]);
				if(!endDate.equalsIgnoreCase(SYMBOL_EMPTY)){
					results.add(endDate);
					break;
				}
			}
		}
		
		return results;
	}
	
	/**
	 * Method parses a string array to look for times
	 * @param splitInput
	 * @return ArrayList containing times
	 */
	private static ArrayList<String> parseStartEndTimes(String[] splitInput){
		String startTime;
		int length = splitInput.length;
		int startIndex = 0;
		ArrayList<String> results = new ArrayList<String>();
		
		for(int i = 0 ; i < length ; i++){
			startTime = parseForTime(splitInput[i]);
			if(!startTime.equalsIgnoreCase(SYMBOL_EMPTY)){
				results.add(startTime);
				startIndex = i;
				break;
			}
		}
	
		if(startIndex != 0 && startIndex < length){
			String endTime;
			for(int j = startIndex + 1 ; j < length ; j++){
				endTime = parseForTime(splitInput[j]);
				if(!endTime.equalsIgnoreCase(SYMBOL_EMPTY)){
					results.add(endTime);
					break;
				}
			}
		}
		return results;
	}
	
	private static String getToday(){
		DateTime now = new DateTime();
		LocalDate today = now.toLocalDate();
		String dateParsed = today.toString(KeywordConstraints.KW_FORMAT_DATE_STORAGE);
		return dateParsed;
	}
	
	private static String parseForDate(String targetString){
		LocalDate curDate = new LocalDate();
		String dateParsed = SYMBOL_EMPTY;
		
		if(!parseForDateWithYear(curDate, targetString).isEmpty()){
			dateParsed = parseForDateWithYear(curDate, targetString);
		} else if (!parseForDateNoYear(curDate, targetString).isEmpty()){
			dateParsed = parseForDateNoYear(curDate, targetString);
		}
		
		return dateParsed;

	}
	
	private static String parseForDateNoYear(LocalDate currentDate, String targetString) {
		LocalDate targetDate = null;
		String dateParsed = SYMBOL_EMPTY;
		
		for(String eachKeyword : KeywordConstraints.KW_FORMAT_DATE_WITHOUT_YEAR){
			try{
				targetDate = DateTimeFormat.forPattern(eachKeyword).parseLocalDate(targetString)
										.withYear(currentDate.getYear());
				dateParsed = targetDate.toString(KeywordConstraints.KW_FORMAT_DATE_STORAGE);
			} catch (IllegalArgumentException e) {
				//nothing 
			}
		}
		return dateParsed;
	}
	
	private static String parseForDateWithYear(LocalDate currentDate, String targetString) {
		LocalDate targetDate = null;
		String dateParsed = SYMBOL_EMPTY;
		
		for(String eachKeyword : KeywordConstraints.KW_FORMAT_DATE_WITH_YEAR){
			try{
				targetDate = DateTimeFormat.forPattern(eachKeyword).parseLocalDate(targetString);
				dateParsed = targetDate.toString(KeywordConstraints.KW_FORMAT_DATE_STORAGE);
			} catch (IllegalArgumentException e){
				//nothing.
			}
		}
		
		return dateParsed;
	}
	
	private static String parseForTime(String targetString){
		LocalTime curTime = null;
		String timeParsed = SYMBOL_EMPTY;
		for(String eachKeyword : KeywordConstraints.KW_FORMAT_TIME){
			try{
			curTime = DateTimeFormat.forPattern(eachKeyword).parseLocalTime(targetString);
			timeParsed = curTime.toString(KeywordConstraints.KW_FORMAT_TIME_STORAGE);
			} catch (IllegalArgumentException e){
				//nothing
			}
		}
		return timeParsed;
	}
	/*
	private static boolean hasDateFlag(String userInput){
		boolean result = false;
		for(String eachKeyword : KeywordConstraints.KW_DATE_FLAG){
			if(userInput.contains(eachKeyword)){
				result = true;
				break;
			}
		}
		
		return result;
	}
	
	private static boolean hasTimeFlag(String userInput){
		boolean result = false;
		for(String eachKeyword : KeywordConstraints.KW_TIME_FLAG){
			if(userInput.contains(eachKeyword)){
				result = true;
				break;
			}
		}
		
		return result;
	}
	*/
}
```
###### \parser\DateTimeParserTest.java
``` java

package parser;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import java.util.ArrayList;
import org.junit.Test;

public class DateTimeParserTest {
	
	@Test
	public void parseDateTimeTest(){
		String userInput = "add hihi 17:30";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("5.30PM");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	
	@Test
	public void parseDateTimeTestWithYearFormatSlash(){
		String userInput = "add ShangHai Major Failure 22/3/16";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	

	@Test
	public void parseDateTimeTestWithYearFormatDash(){
		String userInput = "add ShangHai Major Failure  22-3-16";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}

	@Test
	public void parseDateTimeTestWithYearFormatDot(){
		String userInput = "add ShangHai Major Failure  22.3.16";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}

	@Test
	public void parseDateTimeTestWithYearFormatNothing(){
		String userInput = "add ShangHai Major Failure  220316";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}

	@Test
	public void parseDateTimeTestWithYearFormatEnglishDot(){
		String userInput = "add ShangHai Major Failure  22.March.16";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	
	@Test
	public void parseDateTimeTestWithYearFormatEnglishDash(){
		String userInput = "add ShangHai Major Failure  22-March-16";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	
	@Test
	public void parseDateTimeTestWithoutYearFormatSlash(){
		String userInput = "add ShangHai Major Failure  22/3";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	
	@Test
	public void parseDateTimeTestWithoutYearFormatDash(){
		String userInput = "add ShangHai Major Failure  22-3";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	
	@Test
	public void parseDateTimeTestWithoutYearFormatDot(){
		String userInput = "add ShangHai Major Failure  22.3";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	
	@Test
	public void parseDateTimeTestWithoutYearFormatNothing(){
		String userInput = "add ShangHai Major Failure  2203";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}

	@Test
	public void parseDateTimeTestWithoutYearFormatEnglishDot(){
		String userInput = "add ShangHai Major Failure  22.march";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}

	@Test
	public void parseDateTimeTestWithoutYearFormatEnglishNothing(){
		String userInput = "add ShangHai Major Failure  22March";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}

	@Test
	public void parseDateTimeTestWithoutYearFormatEnglishDash(){
		String userInput = "add ShangHai Major Failure  22-March";
		ArrayList<String> testResults = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResults = new ArrayList<String>();
		expectedResults.add("22/03/16");
		System.out.println(expectedResults.toString());
		System.out.println(testResults.toString());
		assertEquals(expectedResults, testResults);
	}
	
	//WITH TIME
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatColon(){
		String userInput = "add ShangHai Major Failure  22-March  09:30";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatDot(){
		String userInput = "add ShangHai Major Failure  22-March  09.30";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatAPMNothingOnlyHour(){
		String userInput = "add ShangHai Major Failure  22-March  9am";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.00AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatAPMColon(){
		String userInput = "add ShangHai Major Failure  22-March  09:30am";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatAPMDot(){
		String userInput = "add ShangHai Major Failure  22-March  09.30AM";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatAPMNothing(){
		String userInput = "add ShangHai Major Failure  22-March  9.30AM";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	//EQUIVALENCE PARTITIONING UPDATE.
	// TEST : SWAPPED DATE TIME, REORGANIZED TIME/DATE, UNACCEPTABLE TIME, UNACCEPTABLE DATE.
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatDateNotPresent(){
		String userInput = "add ShangHai Major Failure   9pm";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
	
		assertFalse(expectedResultsDate.equals(testResultsDate));
		assertFalse(expectedResultsTime.equals(testResultsTime));
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatTimeNotPresent(){
		String userInput = "add ShangHai Major Failure  1.Jan ";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());
	
		assertFalse(expectedResultsDate.equals(testResultsDate));
		assertFalse(expectedResultsTime.equals(testResultsTime));
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatDateTimeBothNotPresent(){
		String userInput = "add ShangHai Major Failure  ";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());

		assertFalse(expectedResultsDate.equals(testResultsDate));
		assertFalse(expectedResultsTime.equals(testResultsTime));
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatSwapped(){
		String userInput = "add ShangHai Major Failure  9.30AM  22-march";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());

		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatReorganized(){
		String userInput = "add  9.30AM ShangHai  22-march Major Failure";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());

		assertEquals(expectedResultsDate, testResultsDate);
		assertEquals(expectedResultsTime, testResultsTime);
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatUnacceptable(){
		String userInput = "add ShangHai Major Failure  22-March  9o'clock";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());

		assertFalse(expectedResultsTime.equals(testResultsTime));
	}
	
	@Test
	public void parseDateTimeTestWithYearWithTimeFormatDateUnacceptable(){
		String userInput = "add ShangHai Major Failure  334-yule  9.30AM";
		ArrayList<String> testResultsDate = DateTimeParser.parseDateTime(userInput).get(0);
		ArrayList<String> expectedResultsDate = new ArrayList<String>();
		ArrayList<String> testResultsTime = DateTimeParser.parseDateTime(userInput).get(1);
		ArrayList<String> expectedResultsTime = new ArrayList<String>();
		expectedResultsDate.add("22/03/16");
		expectedResultsTime.add("9.30AM");
		System.out.println(expectedResultsDate.toString());
		System.out.println(testResultsDate.toString());
		System.out.println(expectedResultsTime.toString());
		System.out.println(testResultsTime.toString());

		assertFalse(expectedResultsDate.equals(testResultsDate));	
	}	
	
}
```
###### \parser\EventParser.java
``` java

package parser;

import org.joda.time.format.DateTimeFormat;

public class EventParser {
	private static final String SYMBOL_WHITESPACE = " ";
	private static final String SYMBOL_EMPTY = "";
	private static final int COMMAND_WORD_INDEX = 0;
	private static final int ARRAY_MINIMUM_LENGTH = 2; 
	
	/**
	 * Parses the event phrase from a user Input
	 * @param userInput
	 * @return event phrase, with date, time and command word removed.
	 */
	public static String parseEvent(String userInput){
		String inputEvent = removeCommandWord(userInput);
		String resultingEvent = removeDateTime(inputEvent);
		return resultingEvent.trim();
	}
	
	private static String removeCommandWord(String userInput){
		String[] inputArray = userInput.split(SYMBOL_WHITESPACE);
		String remainingText = SYMBOL_EMPTY;
		if(inputArray.length >= ARRAY_MINIMUM_LENGTH) {
			for(int i = 0; i < inputArray.length; i++) {
				if (i != COMMAND_WORD_INDEX){
					remainingText += inputArray[i];
				} 
				
				if(i != inputArray.length) {
					remainingText += SYMBOL_WHITESPACE;
				}
			}
		}
		return remainingText;
	}
	
	private static String removeDateTime(String userInput){
		String extractedEvent = SYMBOL_EMPTY;
		String[] inputArray = userInput.split(SYMBOL_WHITESPACE);
		
		for(int i = 0 ; i <inputArray.length ; i++){
			if(isNotDate(inputArray[i]) && isNotTime(inputArray[i])){
				extractedEvent += inputArray[i];
				extractedEvent += SYMBOL_WHITESPACE;
			} 
		}
		return extractedEvent;
	}
	
	private static boolean isNotDate(String testString){
		boolean noDate = true;
		for(String eachKeyword : KeywordConstraints.KW_FORMAT_DATE_WITH_YEAR){
			try{
				DateTimeFormat.forPattern(eachKeyword).parseLocalTime(testString);
				return false;
			} catch (IllegalArgumentException e){
			
			}
		}
		
		for(String eachKeyword : KeywordConstraints.KW_FORMAT_DATE_WITHOUT_YEAR){
			try{
				DateTimeFormat.forPattern(eachKeyword).parseLocalTime(testString);
				return false;
			} catch (IllegalArgumentException e){
			
			}
		}
		return noDate;
	}
	
	private static boolean isNotTime(String testString){
		boolean noTime = true;
		for(String eachKeyword : KeywordConstraints.KW_FORMAT_TIME){
			try{
				DateTimeFormat.forPattern(eachKeyword).parseLocalTime(testString);
				return false;
			} catch (IllegalArgumentException e){
			
			}
		}
		return noTime;
	}
	
}
```
###### \parser\EventParserTest.java
``` java

package parser;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class EventParserTest {

	@Test
	public void parseEventNoDateNoTime(){
		String userInput = "add Steal ramzes666's keyboard";
		String testResult = EventParser.parseEvent(userInput);
		String expectedResult = "Steal ramzes666's keyboard";
		
		assertEquals(testResult, expectedResult);
	}
	
	@Test
	public void parseEventWithDateNoTime(){
		String userInput = "add Steal ramzes666's keyboard 23-march";
		String testResult = EventParser.parseEvent(userInput);
		String expectedResult = "Steal ramzes666's keyboard";
		
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
	}
	
	@Test
	public void parseEventWithDateWithTime(){
		String userInput = "add Steal ramzes666's keyboard 22-march 2pm";
		String testResult = EventParser.parseEvent(userInput);
		String expectedResult = "Steal ramzes666's keyboard";
		
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
	}
	
	@Test
	public void parseEventWithDateWithTimeReOrganized(){
		String userInput = "add Steal 22-march ramzes666's keyboard 2pm";
		String testResult = EventParser.parseEvent(userInput);
		String expectedResult = "Steal ramzes666's keyboard";
		
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
	}
	
	@Test
	public void parseEventWithDateWith2Time(){
		String userInput = "add Steal 22-march ramzes666's keyboard 2pm";
		String testResult = EventParser.parseEvent(userInput);
		String expectedResult = "Steal ramzes666's keyboard";
		
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
	}
	
	@Test
	public void parseEventWithNothing(){
		String userInput = "add";
		String testResult = EventParser.parseEvent(userInput);
		String expectedResult = "";
		
		System.out.println(testResult);
		assertEquals(testResult, expectedResult);
	}
}
```
###### \parser\IndexParser.java
``` java

package parser;

public class IndexParser {

	private static final String INVALID_INDEX_EXCEPTION = "Invalid index";
	private static final int FIRST_WORD_INDEX = 1;
	
	public static int parseIndex(String userInputEvent){
		String IndexWord = findIndexWord(userInputEvent);
		int parsedInt = tryParse(IndexWord);
		System.out.println(parsedInt);
		return parsedInt;
	}
	
	private static String findIndexWord(String userInputEvent){
		String[] userInputArray = userInputEvent.split(" ");
		try{
			return userInputArray[FIRST_WORD_INDEX];
		} catch (IndexOutOfBoundsException e){
			return INVALID_INDEX_EXCEPTION;
		}
	}
	
	private static int tryParse(String parseWord){
		try{
			return Integer.parseInt(parseWord);
		} catch (NumberFormatException e){
			return -1;
		}
	}

}
```
###### \parser\IndexParserTest.java
``` java

package parser;
import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class IndexParserTest {

	@Test
	public void findIndex(){
		String userInput = "display 1";
		
		int testIndex = IndexParser.parseIndex(userInput);
		int expectedIndex = 1;
		
		assertEquals(expectedIndex, testIndex);
	}
	
	@Test
	public void findIndexLotsOfNumbers(){
		String userInput = "BEGIN_PGP_SIGNATURE 1 2 3 4 5 6 ";
		int testIndex = IndexParser.parseIndex(userInput);
		int expectedIndex = 1;
		
		assertEquals(expectedIndex, testIndex);
	}
}
```
###### \parser\InvalidInputException.java
``` java

package parser;

public class InvalidInputException extends Exception{
	//i honestly have no idea why serialver is needed lolol
	private static final long serialVersionUID = 1L;
	private String message = "Invalid input. Please try again.";

	public InvalidInputException() {

	}

	public InvalidInputException(String messageToUser) {
		this.message = messageToUser;
	}

	public void setMessage(String newMessage){
		this.message = newMessage;
	}

	public String getMessage() {
		return message;
	}
	
}
```
###### \parser\KeywordConstraints.java
``` java

package parser;

public class KeywordConstraints {
	
	// Single Characters
	protected static final String SYMBOL_WHITESPACE = " ";
	protected static final String SYMBOL_NULL = "";
	protected static final String SYMBOL_HYPHEN = "-";
	
	//  Keywords (KW)
	protected static final String[] KW_TASK_ADD = { "add", "++", "/a", "-a" };
	protected static final String[] KW_TASK_CLEAR = { "clear", "nuke"};
	protected static final String[] KW_TASK_DELETE = { "delete", "rm", "del", "-del", "/del", "--" };
	protected static final String[] KW_TASK_DISPLAY = { "ls", "display", "show" };
	protected static final String[] KW_TASK_SEARCH = { "search", "find", "/find", "/f"};
	protected static final String[] KW_TASK_EDIT = { "edit", "change", "update", "-e", "/e" };
	protected static final String[] KW_TASK_MARK_COMPLETE = { "done", "mark", "complete", "-c", "/c" };
	protected static final String[] KW_TASK_MARK_INCOMPLETE = { "undone", "unmark", "notdone", "incomplete", "-ic", "/ic" };
	protected static final String[] KW_TASK_UNDO = { "undo", "/u", "-u" };
	protected static final String[] KW_TASK_REDO = { "redo", "/r", "-r" };
	//UI SPECIFIC KW
	protected static final String[] KW_TASK_EXIT = { "exit", "quit", "-x", "/x"};
	protected static final String[] KW_TASK_HELP = { "help", "-help", "-h", "man"};
	protected static final String[] KW_TASK_CALENDAR = { "calendar", "cal", "-cal", "/cal"};
	protected static final String[] KW_TASK_TUTORIAL = { "tutorial", "tut", "walkthrough", "/tut"};
	
	protected static final String[] KW_TASK_SAVE = { "save" };
	protected static final String[] KW_TASK_SAVETO = {"saveas"};

	//Keywords for TIME/DATE format
	protected static final String[] KW_FORMAT_DATE_WITH_YEAR = { "dd/MM/yy"
																, "dd-MM-yy"
																, "dd.MM.yy"
																, "ddMMyy"
																, "dd.MMMM.yy"
																, "ddMMMMYY"
																, "dd-MMMM-YY"};
	protected static final String[] KW_FORMAT_DATE_WITHOUT_YEAR = { "dd/MM"
																, "dd-MM"
																, "dd.MM"
																, "ddMM"
																, "dd.MMMM"
																, "ddMMMM"
																, "dd-MMMM"};

	protected static final String[] KW_FORMAT_TIME = { "HH:mm"
														, "HH.mm"
														, "hha"
														, "hh:mma"
														, "hh.mma"
														, "hhmma" };
	protected static final String KW_FORMAT_DATE_STORAGE = "dd/MM/yy";
	protected static final String KW_FORMAT_TIME_STORAGE = "h.mma";
}
```
###### \parser\ParserMain.java
``` java

package parser;

import java.util.ArrayList;

import logic.Commands;

public class ParserMain {
	/**
	 * ParserMain
	 * Main role is to take in user input for parsing and formatting.
	 * Delegates calls to the different parsers to complete the job.
	 * returns a formatted String array meant for Logic
	 */
	private static final String INVALID_COMMAND_WORD = "INVALID";
	private static final String INVALID_COMMAND_MESSAGE = "Invalid command. Please try again.";
	private static final String INVALID_EVENT_MESSAGE = "Invalid entry,";
	private static final String INVALID_DATETIME_MESSAGE = "Invalid DateTime Entry";
	private static final String INVALID_INDEX_MESSAGE = "Invalid index. Please try again.";
	
	private static final String SYMBOL_EMPTY = "";
	private static final int TIME_LIST_INDEX = 1;
	private static final int DATE_LIST_INDEX= 0;
	private static final int EVENT_INDEX = 1;
	private static final int COMMAND_INDEX = 0;
	
	private static final int SIZE_EMPTY = 0;
	private static final int SIZE_WITH_START_ONLY = 1;
	private static final int SIZE_WITH_START_AND_END = 2;
	
	
	private static final String[] COMMANDS_REQUIRING_EVENT = {Commands.ADD_COMMAND
																,Commands.DELETE_COMMAND
																,Commands.EDIT_COMMAND};
	
	private static final String[] COMMANDS_REQUIRING_INDEX = {Commands.DELETE_COMMAND
																,Commands.EDIT_COMMAND
																,Commands.DISPLAY_COMMAND
																,Commands.MARK_COMMAND
																,Commands.MARK_INCOMPLETE_COMMAND};
	
	protected ArrayList<String> formattedCommand;
	protected ArrayList<ArrayList<String>> parsedDateTime;
	
	public ParserMain(){
		formattedCommand = new ArrayList<String>();
	}
	
	/**
	 * Method to format and parse user input in a formatted String array
	 * @param userInput
	 * @return String[] containing formatted user input.
	 */
	public String[] processInput(String userInput){
		String commandWords = CommandParser.parseCommand(userInput);
		String eventWords = EventParser.parseEvent(userInput);
		formattedCommand.add(commandWords);
		formattedCommand.add(eventWords);

		checkForErrors();
		String[] returnArray = formattedCommand.toArray(new String[0]);
		formattedCommand.clear();
		return returnArray;
	}
	
	/**
	 * Method extracts date and time from a user input
	 * @param userInput
	 * @return an ArrayList of ArrayList, containing the date time arguments extracted.
	 */
	public ArrayList<ArrayList<String>> processDateTime(String userInput){
		ArrayList<ArrayList<String>> dateTimeWords = DateTimeParser.parseDateTime(userInput);
		parsedDateTime = dateTimeWords;
		checkForErrorsDateTime();
		return dateTimeWords;
	}
	
	private boolean isRequireIndex(String inputCommand){
		boolean result = false;
		for(String eachCommand : COMMANDS_REQUIRING_INDEX){
			if(inputCommand.equalsIgnoreCase(eachCommand)){
				result = true;
				break;
			}
		}
		return result;
	}
	
	private int parseInt(String inputString){
		return IndexParser.parseIndex(inputString);
	}
	
	private void checkForErrors(){
		if(isCommandInvalid()){
			setInputInvalid(INVALID_COMMAND_MESSAGE);
		} else if(isIndexInvalid()){
			setInputInvalid(INVALID_INDEX_MESSAGE);
		} else if(isEventInvalid()){
			setInputInvalid(INVALID_EVENT_MESSAGE);
		}
	}
	
	private void checkForErrorsDateTime(){
		if(isDateTimeInvalid()){
			setInputInvalid(INVALID_DATETIME_MESSAGE);
		 }
	}
	
	
	private void setInputInvalid(String invalidMessage){
		formattedCommand.clear();
		formattedCommand.add(INVALID_COMMAND_WORD);
		formattedCommand.add(invalidMessage);
	}
	
	private boolean isCommandInvalid(){
		String receivedCommand = formattedCommand.get(COMMAND_INDEX);
		return receivedCommand.equalsIgnoreCase(INVALID_COMMAND_WORD);
	}
	
	private boolean isIndexInvalid(){
		String receivedCommand = formattedCommand.get(COMMAND_INDEX);
		boolean result = true;
		int receivedIndex = 0;
		if(isRequireIndex(receivedCommand)){
			receivedIndex = parseInt(receivedCommand + " " 
							+ formattedCommand.get(EVENT_INDEX));
		}
		
		if(receivedIndex >=0){
			result = false;
		}
		
		return result;
	}
	
	private boolean isEventInvalid(){
		String receivedEvent = formattedCommand.get(EVENT_INDEX);
		String receivedCommand = formattedCommand.get(COMMAND_INDEX);
		
		boolean isCommandRequiringEvent = false;
		boolean isEventEmpty = receivedEvent.equalsIgnoreCase(SYMBOL_EMPTY);
		for(String eachCommand : COMMANDS_REQUIRING_EVENT){
			if(receivedCommand.equalsIgnoreCase(eachCommand)){
				isCommandRequiringEvent = true;
				break;
			}
		}
		return isCommandRequiringEvent&&isEventEmpty;
	}
	
	private boolean isDateTimeInvalid(){
		ArrayList<String> dateArgs = parsedDateTime.get(DATE_LIST_INDEX);
		ArrayList<String> timeArgs = parsedDateTime.get(TIME_LIST_INDEX);
		if(dateArgs.size() != SIZE_EMPTY
			|| dateArgs.size() != SIZE_WITH_START_ONLY
			|| dateArgs.size() != SIZE_WITH_START_AND_END){
			return false;
		}
		
		if(timeArgs.size() != SIZE_EMPTY
			|| timeArgs.size() != SIZE_WITH_START_ONLY
			|| timeArgs.size() != SIZE_WITH_START_AND_END){
				return false;
		}
		return true;
	}
}
```
