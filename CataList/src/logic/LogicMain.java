//@@author a0124946
package logic;

import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;

import parser.ParserMain;
import shared.LogHandler;
import storage.StorageMain;

public class LogicMain {
	
	
	/**
	 * 	LogicMain receives the user input from UI and passes them to Parser and LogicHandler.
	 * 	The role of LogicMain is to operate on Task Objects, created by LogicHandler.
	 *  It also provides API(s) for UI, and provide feedback after every input.
	 *  
	 */
	
	private ArrayList<Task> completeTasks;
	private ArrayList<Task> incompleteTasks;
	private ArrayList<Task> masterListTasks;
	
	private ArrayList<Task> operatingTasks;
	
	private ArrayList<ArrayList<Task>> state;
	private int pointingAt;
	
	private static final int INCOMPLETE_LIST_INDEX = 0;
	private static final int COMPLETE_LIST_INDEX = 1;
	private static final int MASTER_LIST_INDEX = 2;
	private static final int INPUT_INDEX_TO_ARRAY_CORRECTION = 1;
	
	private static final String UNKNOWN_OPERATION_NOTICE = "UNKNOWN OPERATION";
	private static final String SYMBOL_SPACE = " ";
	private static final String SYMBOL_EMPTY = "";
	
	private static final Logger log = LogHandler.retrieveLog();
	ParserMain inputParser;
	StorageMain storageSystem;
	
	/** 
	 * LogicMain()
	 * Initialise LogicMain and its dependencies
	 */
	
	public LogicMain() {
		init();
		regenerateSubListsFromMasterList();
		updateOperating();
		state.add(new ArrayList<Task>(masterListTasks));
		pointingAt = 0;
	}
	
	/**
	 * Method processes user input
	 * by calling dependencies Parser and LogicHandler
	 * @param userInput is the input received from UI.
	 * @return feedBack message generated by command.
	 */
	
	public String processCommand(String userInput) {
		String[] formattedInput = inputParser.processInput(userInput);
		ArrayList<ArrayList<String>> dateTimeArgs = inputParser.processDateTime(userInput);
		Task newCreatedTask = LogicHandler.processCommand(formattedInput, dateTimeArgs);
		String feedbackToUI = operateOnTask(newCreatedTask);

		logList();
		if(isMutatorAndNotUndoRedo(newCreatedTask)) {
			updateState();
		}
		
		sortList();
		regenerateSubListsFromMasterList();
		
		if(!isSearchOrDisplay(newCreatedTask)) {
			updateOperating();
		}
		logList();
		storageSystem.storageWrite(masterListTasks);
		return feedbackToUI;
	}
	
	/**
	 * Method to return list of operatingTasks
	 * @return operatingTasks
	 */
	public ArrayList<Task> getOperatingTasksForUI() {
		return operatingTasks;
	}
	
	/**
	 * Method to return list of completed Tasks
	 * @return completedTasks
	 */
	public ArrayList<Task> getCompleteTasksForUI() {

		return completeTasks;
	}
	
	/**
	 * Method to return list of incomplete tasks
	 * @return incompleteTasks
	 */
	public ArrayList<Task> getIncompleteTasksForUI() {
		return incompleteTasks;
	}
	
	/**
	 * Method to change the contents of operatingTasks to that of Master List
	 */
	public void operatingToMaster(){
		operatingTasks = new ArrayList<Task>(masterListTasks);
	}
	
	/**
	 * Method to change the contents of operatingTasks to that of Incomplete List
	 */
	public void operatingToIncomplete(){
		operatingTasks = new ArrayList<Task>(incompleteTasks);
	}
	
	/**
	 * Method to change the contents of operatingTasks to that of Complete List
	 */
	public void operatingToComplete(){
		operatingTasks = new ArrayList<Task>(completeTasks);
	}
	
	private void init() {
		inputParser = new ParserMain();
		storageSystem = new StorageMain();
		
		masterListTasks = new ArrayList<Task>();
		completeTasks = new ArrayList<Task>();
		incompleteTasks = new ArrayList<Task>();
		state = new ArrayList<ArrayList<Task>>();
		
		masterListTasks = new ArrayList<Task>(storageSystem.loadTask());	
	}
	
	private boolean isSearchOrDisplay(Task taskInput) {
		boolean result = false;
		if(taskInput.get_cmd().equalsIgnoreCase(Commands.SEARCH_COMMAND)) {
			result = true;
		} else if (taskInput.get_cmd().equalsIgnoreCase(Commands.DISPLAY_COMMAND)) {
			result = true;
		}
		return result;
	}	
	
	private String operateOnTask(Task requestedTask) {
		String commandType = requestedTask.get_cmd();
		switch(commandType) {
			case Commands.ADD_COMMAND :
				return doAdd(requestedTask);
			case Commands.DELETE_COMMAND :
				return doDelete(requestedTask);
			case Commands.CLEAR_COMMAND :
				return doClear(requestedTask);
			case Commands.DISPLAY_COMMAND :
				return doDisplay(requestedTask);
			case Commands.EDIT_COMMAND :
				return doEdit(requestedTask);
			case Commands.REDO_COMMAND : 
				return doRedo(requestedTask);
			case Commands.UNDO_COMMAND :
				return doUndo(requestedTask);
			case Commands.SEARCH_COMMAND:
				return doSearch(requestedTask);
			case Commands.MARK_COMMAND :
				return doMarkComplete(requestedTask);
			case Commands.MARK_INCOMPLETE_COMMAND :
				return doMarkIncomplete(requestedTask);
			case Commands.HELP_COMMAND :
			case Commands.TUTORIAL_COMMAND :
			case Commands.CALENDAR_COMMAND :
			case Commands.EXIT_COMMAND :
			case Commands.SAVEAS_COMMAND:
				return opForUI(requestedTask);
			case Commands.INVALID_COMMAND :
				return doInvalid(requestedTask);
			case Commands.SAVE_COMMAND:
				return doSave(requestedTask);
			default: 
				return UNKNOWN_OPERATION_NOTICE;
		}
	}
	
	private void updateState() {
		ArrayList<Task> addToState = new ArrayList<Task>(masterListTasks);
		state.add(addToState);
		pointingAt++;
	}
	
	private void updateOperating() {
		operatingTasks = new ArrayList<Task>(incompleteTasks);
	}
	
	/**
	 * Rebuilds completeTask and incompleteTask from masterList
	 */
	private void regenerateSubListsFromMasterList() {
		incompleteTasks.clear();
		completeTasks.clear();
		for(Task eachTask : masterListTasks) {
			if(eachTask.get_completionState()) {
				completeTasks.add(eachTask);
			} else {
				incompleteTasks.add(eachTask);
			}
		}
	}
	
	private ArrayList<Task> sortList() {
		Collections.sort(masterListTasks);
		return masterListTasks;
	}
	
	/*
	private void saveBackToOriginalList() {
		if(operatingOn == MASTER_LIST_INDEX) {
			masterListTasks = operatingTasks;
		} else if (operatingOn == COMPLETE_LIST_INDEX) {
			completeTasks = operatingTasks;
		} else if (operatingOn == INCOMPLETE_LIST_INDEX) {
			incompleteTasks = operatingTasks;
		}
	}
	*/
	/**
	 * Method checks whether a task is not a REDO/UNDO operation
	 * @param inputTask
	 * @return boolean indicating result
	 */
	private boolean isMutatorAndNotUndoRedo(Task inputTask) {
		boolean result = false;
		if(inputTask.get_cmd().equalsIgnoreCase(Commands.UNDO_COMMAND)
				||inputTask.get_cmd().equalsIgnoreCase(Commands.REDO_COMMAND)) {
			 result = false;
		} else if(inputTask.is_changed()) {
			result = true;
		} 
		return result;
	}
	
	/**
	 * Adds the task to masterListTasks
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doAdd(Task taskToOp) {
		String feedBack;
		try{
			masterListTasks.add(taskToOp);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (Exception e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		return feedBack;
	}
	
	/**
	 * Method deletes all occurrences of this task in masterListTasks and operatingTasks
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doDelete(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		try{
			Task toDelete = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);

			for(int i = 0 ; i < masterListTasks.size() ; i++) {
				if(masterListTasks.get(i).equals(toDelete)) {
					masterListTasks.remove(i);
				}
			}
		
			operatingTasks.remove(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		return feedBack;
	}
	
	/**
	 * Clears every taskList
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doClear(Task taskToOp) {
		String feedBack = taskToOp.get_messageToUserSuccess();
		
		incompleteTasks.clear();
		completeTasks.clear();
		masterListTasks.clear();
		
		operatingTasks.clear();
		return feedBack;
	}
	
	/**
	 * Method changes what operatingTasks contains.
	 * @param taskToOp
	 * @return feedback message
	 */
	
	private String doDisplay(Task taskToOp) {
		int listToDisplay = taskToOp.get_index();
		String feedBack = taskToOp.get_messageToUserSuccess();		
		
		if(listToDisplay == COMPLETE_LIST_INDEX) {
			operatingTasks = new ArrayList<Task>(completeTasks);
		} else if (listToDisplay == INCOMPLETE_LIST_INDEX) {
			operatingTasks = new ArrayList<Task>(incompleteTasks);
		} else if(listToDisplay == MASTER_LIST_INDEX) {
			operatingTasks = new ArrayList<Task>(masterListTasks);
		} else {
			return taskToOp.get_messageToUserFail();
		}

		return feedBack;
	}
	
	/**
	 * Method edits a single task Object
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doEdit(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		
		try{
			Task toEdit = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			Task cloneTask = (Task) toEdit.cloneOf();
			cloneTask.editWith(taskToOp);
		
			doOperateOnMasterAndOperating(toEdit, cloneTask, operateIndex);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	
	private String doUndo(Task taskToOp) {
		String feedBack;
		try{
			pointingAt--;
			masterListTasks = new ArrayList<Task>(state.get(pointingAt));
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	private String doRedo(Task taskToOp) {
		String feedBack;
		try{
			pointingAt++;
			masterListTasks =  new ArrayList<Task>(state.get(pointingAt));
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch (IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	/**
	 * Searches through all tasks, adding to list primarily those that fit the search keyword most
	 * followed by substring sequences.
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doSearch(Task taskToOp) {
		String toFind = taskToOp.get_task();
		ArrayList<Task> foundList = new ArrayList<Task>();
		foundList = doSearchFullString(toFind);
		ArrayList<Task> foundListSecondary = doSearchSubsequence(toFind, foundList);
		
		if(!foundListSecondary.isEmpty()) {
			foundList.addAll(foundListSecondary);
		}
		
		operatingTasks = new ArrayList<Task>(foundList);
		return taskToOp.get_messageToUserSuccess();
	}
	
	private ArrayList<Task> doSearchFullString(String toFind) {
		ArrayList<Task> foundList = new ArrayList<Task>();

		for(Task eachTask : masterListTasks) {
			if(eachTask.get_task().contains(toFind)) {
				foundList.add(eachTask);
			}
		}
		return foundList;
	}
	
	private ArrayList<Task> doSearchSubsequence(String toFind, ArrayList<Task> primaryList){
		ArrayList<Task> foundList = new ArrayList<Task>();

		for(Task eachTask : masterListTasks) {
			String[] splitFind = toFind.split(SYMBOL_SPACE);
			for(String eachString : splitFind) {
				if(eachTask.get_task().contains(eachString)) {
					if(!primaryList.contains(eachTask)) {
						foundList.add(eachTask);
					}
				}
			}
		}
		
		return foundList;
	}
	
	private String doMarkComplete(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		try{
			Task operateOn = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			Task cloneTask = (Task) operateOn.cloneOf();
			cloneTask.set_Complete();

			doOperateOnMasterAndOperating(operateOn, cloneTask, operateIndex);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch(IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	private String doMarkIncomplete(Task taskToOp) {
		int operateIndex = taskToOp.get_index();
		String feedBack;
		try{
			Task operateOn = operatingTasks.get(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION);
			Task cloneTask = (Task) operateOn.cloneOf();
			cloneTask.set_Incomplete();
	
			doOperateOnMasterAndOperating(operateOn, cloneTask, operateIndex);
			feedBack = taskToOp.get_messageToUserSuccess();
		} catch(IndexOutOfBoundsException e) {
			log.log(Level.SEVERE, e.toString(), e);
			feedBack = taskToOp.get_messageToUserFail();
		}
		
		return feedBack;
	}
	
	private String doInvalid(Task taskToOp) {
		String feedBack = taskToOp.get_messageToUserSuccess();
		return feedBack;
	}
	
	/**
	 * Retrieves a feedback message from tasks
	 * @param taskToOp
	 * @return feedback message
	 */
	private String opForUI(Task taskToOp) {
		String feedBack = taskToOp.get_messageToUserSuccess();
		return feedBack;
	}
	
	/**
	 * Changes file save location.
	 * @param taskToOp
	 * @return feedback message
	 */
	private String doSave(Task taskToOp){
		String feedBack;
		String newLoc = taskToOp.get_task();
		assert newLoc != null;
		assert newLoc != SYMBOL_EMPTY;
		if(!newLoc.isEmpty()) {
			try{
				storageSystem.saveFileLocation(newLoc);
				feedBack = taskToOp.get_messageToUserSuccess();
			} catch (Exception e) {
				log.log(Level.SEVERE, e.toString(), e);
				feedBack = taskToOp.get_messageToUserFail();
			}
		} else {
			feedBack = taskToOp.get_messageToUserFail();
		}
		return feedBack;
	}
	
	/**
	 * Method looks at the task object required to be operated upon
	 * and looks for the same object inside the master list before
	 * executing the same operation on both.
	 * @param operateOn is the task object from operatingTask
	 * @param replaceWith is the task object to be changed
	 * @param operateIndex is the index where operateOn can be found in operatingTask
	 */
	private void doOperateOnMasterAndOperating(Task operateOn, Task replaceWith, int operateIndex) {
		for(int i = 0 ; i < masterListTasks.size() ; i++) {
			if(masterListTasks.get(i).equals(operateOn)) {
				System.out.println(masterListTasks.get(i).get_task() + " is being operated on.");
				masterListTasks.set(i, replaceWith);
			}
		}
		operatingTasks.set(operateIndex - INPUT_INDEX_TO_ARRAY_CORRECTION, replaceWith);	
	}
	
	private void logList(){
		for(Task eachTask : masterListTasks){
			log.log(Level.FINE, "Item in master list", eachTask);
		}
		
		for(Task eachTask : operatingTasks){
			log.log(Level.FINE, "Item in operating list", eachTask);
		}
		
		for(Task eachTask : completeTasks){
			log.log(Level.FINE, "Item in complete list", eachTask);
		}
		
		for(Task eachTask : incompleteTasks){
			log.log(Level.FINE, "Item in incomplete list", eachTask);
		}
	}
	
}